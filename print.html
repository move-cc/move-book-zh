<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move Book 中文版</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Book 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use case is for the Diem blockchain, where Move provides the foundation for its implementation. Move allows developers to write programs that flexibly manage and transfer assets, while providing the security and protections against attacks on those assets. However, Move has been developed with use cases in mind outside a blockchain context as well.</p>
<p>Move takes its cue from <a href="https://www.rust-lang.org/">Rust</a> by using resource types with move (hence the name) semantics as an explicit representation of digital assets, such as currency.</p>
<h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>欢迎使用 Move，这是一种用于安全、沙盒和形式化验证的下一代编程语言。
它的第一个用例是 Diem 区块链，Move 为其实现提供了基础。
Move 允许开发人员编写灵活地管理和转移资产的程序，同时提供安全保护，防止那些对资产攻击的行为。
不仅如此，Move 也可用于区块链之外的开发场景。</p>
<p>Move 的诞生从 <a href="https://www.rust-lang.org/">Rust</a> 中的*所有权（ownership）<em>机制汲取了灵感，通过使用具有</em>移动（move）*语义的资源类型作为数字资产（例如货币）的显示表示，Move 也因此而得名。</p>
<h2 id="who-is-move-for"><a class="header" href="#who-is-move-for">Who is Move for?</a></h2>
<p>Move was designed and created as a secure, verified, yet flexible programming language. The first use of Move is for the implementation of the Diem blockchain. That said, the language is still evolving. Move has the potential to be a language for other blockchains, and even non-blockchain use cases as well.</p>
<p>Given custom Move modules will not be supported at the <a href="https://diem.com/white-paper/#whats-next">launch</a> of the Diem Payment Network (DPN), we are targeting an early Move Developer persona.</p>
<p>The early Move Developer is one with some programming experience, who wants to begin understanding the core programming language and see examples of its usage.</p>
<h2 id="move-是为谁而准备的"><a class="header" href="#move-是为谁而准备的">Move 是为谁而准备的？</a></h2>
<p>Move 被设计和创建为一种安全、经过验证且灵活的编程语言。
Move 的第一个用途是实现 Diem 区块链。也就是说，语言仍在不断发展。
Move 有可能成为其他区块链甚至非区块链用例的语言。</p>
<p>鉴于在 Diem 支付网络 (DPN) 启动时将不支持自定义 Move 模块，我们的目标是早期的 Move 开发人员。</p>
<p>早期的 Move 开发人员是具有一定编程经验的人，他们希望开始了解核心编程语言并查看其使用示例。</p>
<h3 id="hobbyists"><a class="header" href="#hobbyists">Hobbyists</a></h3>
<p>Understanding that the capability to create custom modules on the Diem Payment Network will not be available at launch, the hobbyist Move Developer is interested in learning the intricacies of the language. She will understand the basic syntax, the standard libraries available, and write example code that can be executed using the Move CLI. The Move Developer may even want to dig into understanding how the Move Virtual Machine executes the code she writes.</p>
<h3 id="爱好者"><a class="header" href="#爱好者">爱好者</a></h3>
<p>了解在 Diem 支付网络上创建自定义模块的功能在发布时将不可用，爱好 Move 的开发人员有兴趣学习该语言的复杂性。
她将了解基本语法、可用的标准库，并编写可以使用 Move CLI 执行的示例代码。
Move 开发人员甚至可能想深入了解 Move 虚拟机如何执行她编写的代码。</p>
<h3 id="core-contributor"><a class="header" href="#core-contributor">Core Contributor</a></h3>
<p>Beyond a hobbyist wanting to stay ahead of the curve for the core programming language is someone who may want to <a href="https://diem.com/en-US/cla-sign/">contribute</a> directly to Move. Whether this includes submitting language improvements or even, in the future, adding core modules available on the Diem Payment Network, the core contributor will understand Move at a deep level.</p>
<h3 id="核心贡献者"><a class="header" href="#核心贡献者">核心贡献者</a></h3>
<p>除了想要在核心编程语言方面保持领先的业余爱好者之外，还有可能想要直接为 Move 做出贡献的人。
无论这包括提交语言改进，还是将来添加 Diem 支付网络上可用的核心模块，核心贡献者都将深入了解 Move。</p>
<h3 id="who-move-is-currently-not-targeting"><a class="header" href="#who-move-is-currently-not-targeting">Who Move is currently not targeting</a></h3>
<p>Currently, Move is not targeting developers who wish to create custom modules and contracts for use on the Diem Payment Network. We are also not targeting novice developers who expect a completely polished developer experience even in testing the language.</p>
<h3 id="move-目前不适用于哪些人"><a class="header" href="#move-目前不适用于哪些人">Move 目前不适用于哪些人</a></h3>
<p>目前，Move 不针对希望创建自定义模块和合约以在 Diem 支付网络上使用的开发人员。
我们也不针对那些期望在语言测试阶段就获得完美开发体验的新手开发者。</p>
<h2 id="where-do-i-start"><a class="header" href="#where-do-i-start">Where Do I Start?</a></h2>
<p>Begin with understanding <a href="./modules-and-scripts.html">modules and scripts</a> and then work through the <a href="./creating-coins.html">Move Tutorial</a>.</p>
<h2 id="我该从哪里开始呢"><a class="header" href="#我该从哪里开始呢">我该从哪里开始呢？</a></h2>
<p>从了解<a href="./modules-and-scripts.html">模块和脚本</a>开始，然后完成<a href="./creating-coins.html">Move 教程</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块和脚本"><a class="header" href="#模块和脚本">模块和脚本</a></h1>
<p>Move 有两种不同类型的程序：<em><strong>模块（Module）<em><strong>和</strong></em>脚本（Script）</strong></em>。模块是定义结构类型以及对这些类型进行操作的函数的库。<em>结构类型</em>定义了 Move 的<a href="./global-storage-structure.html">全局存储</a>的模式，<em>模块函数</em>定义了更新存储的规则。模块本身也存储在全局存储中。脚本是<a href="https://en.wikipedia.org/wiki/Executable">可执行文件</a>的入口点，类似于传统语言中的主函数 <code>main</code>。脚本通常调用已发布模块的函数来更新全局存储。脚本是临时代码片段，不会发布在全局存储中。</p>
<p>一个 Move 源文件（或<strong>编译单元</strong>）可能包含多个模块和脚本。然而，发布模块或执行脚本都是独立的虚拟机（VM）操作。</p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="脚本"><a class="header" href="#脚本">脚本</a></h3>
<p>脚本具有以下结构：</p>
<pre><code class="language-text">script {
    &lt;use&gt;*
    &lt;constants&gt;*
    fun &lt;identifier&gt;&lt;[type parameters: constraint]*&gt;([identifier: type]*) &lt;function_body&gt;
}
</code></pre>
<p>一个 <code>script</code> 块必须以它的所有 <a href="./uses.html"><code>use</code></a> 声明开头，然后是<a href="./constants.html">常量（constant）</a>声明，最后是主<a href="./functions.html">函数</a>声明。主函数的名称可以是任意的（也就是说，它不一定命名为 <code>main</code>），它是脚本块中唯一的函数，可以有任意数量的参数，并且不能有返回值。下面是每个组件的示例：</p>
<pre><code class="language-move">script {
    // 导入在命名账户地址 std 上发布的 debug 模块。
    use std::debug;

    const ONE: u64 = 1;

    fun main(x: u64) {
        let sum = x + ONE;
        debug::print(&amp;sum)
    }
}
</code></pre>
<p>脚本（Script）的功能非常有限 —— 它们不能声明友元（friend）、结构类型或访问全局存储。他们的主要作用主要是调用<em>模块函数</em>。</p>
<h3 id="模块"><a class="header" href="#模块">模块</a></h3>
<p>模块具有以下结构：</p>
<pre><code class="language-text">module &lt;address&gt;::&lt;identifier&gt; {
    (&lt;use&gt; | &lt;friend&gt; | &lt;type&gt; | &lt;function&gt; | &lt;constant&gt;)*
}
</code></pre>
<p>其中 <code>&lt;address&gt;</code> 是一个有效的<a href="./address.html">命名或字面量地址</a>。</p>
<p>例子：</p>
<pre><code class="language-move">module 0x42::test {
    struct Example has copy, drop { i: u64 }

    use std::debug;
    friend 0x42::another_test;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&amp;sum)
    }
}
</code></pre>
<p><code>module 0x42::test</code> 这部分指定模块 <code>test</code> 将在<a href="./global-storage-structure.html">全局存储</a>的<a href="./address.html">账户地址</a> <code>0x42</code> 下发布。</p>
<p>模块也可以使用<a href="./address.html">命名地址</a>来声明，例如：</p>
<pre><code class="language-move">module test_addr::test {
    struct Example has copy, drop { a: address }

    use std::debug;
    friend test_addr::another_test;

    public fun print() {
        let example = Example { a: @test_addr };
        debug::print(&amp;example)
    }
}
</code></pre>
<p>因为命名地址只存在于源语言级别和编译期间，所以命名地址将在字节码级别彻底替换它们的值。例如，如果我们有以下代码：</p>
<pre><code class="language-move">script {
    fun example() {
        my_addr::m::foo(@my_addr);
    }
}
</code></pre>
<p>我们在把 <code>my_addr</code> 设置为 <code>0xC0FFEE</code> 的情况下编译它，那么它在操作上等同于以下内容：</p>
<pre><code class="language-move">script {
    fun example() {
        0xC0FFEE::m::foo(@0xC0FFEE);
    }
}
</code></pre>
<p>然而，在源代码级别，这些是<em>不等价的</em> —— 函数 <code>m::foo</code> <em>必须</em>通过 <code>my_addr</code> 命名地址来访问，而不是通过分配给该地址的数值来访问。</p>
<p>模块名称可以以字母 <code>a</code> 到 <code>z</code> 或字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字符之后，模块名可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code>、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">module my_module {}
module foo_bar_42 {}
</code></pre>
<p>通常，模块名称以小写字母开头。名为 <code>my_module</code> 的模块应该存储在名为 <code>my_module.move</code> 的源文件中。</p>
<p><code>module</code> 块内的所有元素都可以按任意顺序出现。从根本上说，模块是<a href="./structs-and-resources.html"><code>类型（type）</code></a>和<a href="./functions.html"><code>函数（function）</code></a>的集合。<a href="./uses.html"><code>use</code></a> 关键字用来从其他模块导入类型。<a href="./friends.html"><code>friend</code></a> 关键字指定一个可信的模块列表。<a href="./constants.html"><code>const</code></a> 关键字定义了可以在模块函数中使用的私有常量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-教程move-tutorial"><a class="header" href="#move-教程move-tutorial">Move 教程（Move Tutorial）</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integers"><a class="header" href="#integers">Integers</a></h1>
<p>Move supports three unsigned integer types: <code>u8</code>, <code>u64</code>, and <code>u128</code>. Values of these types range from 0 to a maximum that depends on the size of the type.</p>
<h1 id="整数"><a class="header" href="#整数">整数</a></h1>
<p>Move 支持三种无符号整数类型：u8、u64 和 u128。这些类型的值范围从 0 到最大值，具体取决于类型的大小。</p>
<table><thead><tr><th>Type</th><th>Value Range</th></tr></thead><tbody>
<tr><td>Unsigned 8-bit integer, <code>u8</code></td><td>0 to 2<sup>8</sup> - 1</td></tr>
<tr><td>Unsigned 64-bit integer, <code>u64</code></td><td>0 to 2<sup>64</sup> - 1</td></tr>
<tr><td>Unsigned 128-bit integer, <code>u128</code></td><td>0 to 2<sup>128</sup> - 1</td></tr>
</tbody></table>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literal values for these types are specified either as a sequence of digits (e.g.,<code>112</code>) or as hex literals, e.g., <code>0xFF</code>. The type of the literal can optionally be added as a suffix, e.g., <code>112u8</code>. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be <code>u64</code>.</p>
<p>If a literal is too large for its specified (or inferred) size range, an error is reported.</p>
<h2 id="字面量"><a class="header" href="#字面量">字面量</a></h2>
<p>这些类型的文字值指定为数字序列（例如，112）或十六进制文字，例如，0xFF。可以选择将文字的类型添加为后缀，例如 112u8。如果未指定类型，编译器将尝试从使用文字的上下文推断类型。如果无法推断类型，则假定为 u64。</p>
<p>如果文字对于其指定的（或推断的）大小范围来说太大，则会报告错误。</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<pre><code class="language-move">// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 &lt;&lt; complex_u8;

let x: u8 = 0;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 3; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
</code></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>Each of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) <em>must</em> be of the same type. If you need to operate over values of different types, you will need to first perform a <a href="integers.html#casting">cast</a>. Similarly, if you expect the result of the operation to be too large for the integer type, perform a <a href="integers.html#casting">cast</a> to a larger size before performing the operation.</p>
<p>All arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).</p>
<h2 id="运营"><a class="header" href="#运营">运营</a></h2>
<h3 id="算术"><a class="header" href="#算术">算术</a></h3>
<p>这些类型中的每一种都支持相同的检查算术运算集。对于所有这些操作，两个参数（左侧和右侧操作数）必须是同一类型。如果您需要对不同类型的值进行操作，则需要首先执行强制转换。同样，如果您预计运算结果对于整数类型来说太大，请在执行运算之前执行转换为更大的大小。</p>
<p>所有算术运算都会中止，而不是以数学整数不会的方式表现（例如，上溢、下溢、被零除）。</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>%</code></td><td>modular division</td><td>The divisor is <code>0</code></td></tr>
<tr><td><code>/</code></td><td>truncating division</td><td>The divisor is <code>0</code></td></tr>
</tbody></table>
<h3 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h3>
<p>The integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.</p>
<p>Bitwise operations do not abort.</p>
<h3 id="按位"><a class="header" href="#按位">按位</a></h3>
<p>整数类型支持以下按位运算，将每个数字视为一系列单独的位，0 或 1，而不是数字整数值。</p>
<p>按位运算不会中止。</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>bitwise and</td><td>Performs a boolean and for each bit pairwise</td></tr>
<tr><td>`</td><td>`</td><td>bitwise or</td></tr>
<tr><td><code>^</code></td><td>bitwise xor</td><td>Performs a boolean exclusive or for each bit pairwise</td></tr>
</tbody></table>
<h3 id="bit-shifts"><a class="header" href="#bit-shifts">Bit Shifts</a></h3>
<p>Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other operations, the righthand side operand (how many bits to shift by) must <em>always</em> be a <code>u8</code> and need not match the left side operand (the number you are shifting).</p>
<p>Bit shifts can abort if the number of bits to shift by is greater than or equal to <code>8</code>, <code>64</code>, or <code>128</code> for <code>u8</code>, <code>u64</code>, and <code>u128</code> respectively.</p>
<h3 id="位移"><a class="header" href="#位移">位移</a></h3>
<p>与按位运算类似，每种整数类型都支持位移。但与其他操作不同，右侧操作数（要移位多少位）必须始终是 u8 并且不需要匹配左侧操作数（您要移位的数字）。</p>
<p>如果要移位的位数分别大于或等于 u8、u64 和 u128 的 8、64 或 128，则移位可以中止。</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;</code></td><td>shift left</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>shift right</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
</tbody></table>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>Integer types are the <em>only</em> types in Move that can use the comparison operators. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="integers.html#casting">cast</a> one of them first.</p>
<p>Comparison operations do not abort.</p>
<h3 id="比较"><a class="header" href="#比较">比较</a></h3>
<p>整数类型是 Move 中唯一可以使用比较运算符的类型。两个参数必须是同一类型。如果您需要比较不同类型的整数，则需要先转换其中一个。</p>
<p>比较操作不会中止。</p>
<table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>&lt;</code></td><td>less than</td></tr>
<tr><td><code>&gt;</code></td><td>greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>less than or equal to</td></tr>
<tr><td><code>&gt;=</code></td><td>greater than or equal to</td></tr>
</tbody></table>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<p>Like all types with <a href="./abilities.html"><code>drop</code></a> in Move, all integer types support the <a href="./equality.html">&quot;equal&quot;</a> and <a href="./equality.html">&quot;not equal&quot;</a>  operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to <a href="integers.html#casting">cast</a> one of them first.</p>
<p>Equality operations do not abort.</p>
<h3 id="平等"><a class="header" href="#平等">平等</a></h3>
<p>与 Move 中的所有类型一样，所有整数类型都支持“等于”和“不等于”操作。两个参数必须是同一类型。如果您需要比较不同类型的整数，则需要先转换其中一个。</p>
<p>平等操作不会中止。</p>
<table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td></tr>
<tr><td><code>!=</code></td><td>not equal</td></tr>
</tbody></table>
<p>For more details see the section on <a href="./equality.html">equality</a></p>
<p>有关更多详细信息，请参阅平等部分</p>
<h2 id="casting"><a class="header" href="#casting">Casting</a></h2>
<p>Integer types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.</p>
<p>Casts <em>do not</em> truncate. Casting will abort if the result is too large for the specified type</p>
<h2 id="铸件"><a class="header" href="#铸件">铸件</a></h2>
<p>一种大小的整数类型可以转换为另一种大小的整数类型。整数是 Move 中唯一支持强制转换的类型。</p>
<p>强制转换不会截断。如果结果对于指定类型来说太大，则转换将中止</p>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>(e as T)</code></td><td>Cast integer expression <code>e</code> into an integer type <code>T</code></td><td><code>e</code> is too large to represent as a <code>T</code></td></tr>
</tbody></table>
<p>Here, the type of <code>e</code> must be <code>u8</code>, <code>u64</code>, or <code>u128</code> and <code>T</code> must be <code>u8</code>, <code>u64</code>, or <code>u128</code>.</p>
<p>For example:</p>
<p>这里，e 的类型必须是 u8、u64 或 u128，T 必须是 u8、u64 或 u128。</p>
<p>例如：</p>
<ul>
<li><code>(x as u8)</code></li>
<li><code>(2u8 as u64)</code></li>
<li><code>(1 + 3 as u128)</code></li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as <a href="./variables.html#move-and-copy"><code>copy</code></a>.</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p>与语言内置的其他标量值一样，整数值是隐式可复制的，这意味着它们可以在没有显式指令（如复制）的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">Bool</a></h1>
<p><code>bool</code> is Move's primitive type for boolean <code>true</code> and <code>false</code> values.</p>
<h1 id="布尔"><a class="header" href="#布尔">布尔</a></h1>
<p>bool 是 Move 的布尔真假值的原始类型。</p>
<h2 id="literals-1"><a class="header" href="#literals-1">Literals</a></h2>
<p>Literals for <code>bool</code> are either <code>true</code> or <code>false</code>.</p>
<h2 id="字面量-1"><a class="header" href="#字面量-1">字面量</a></h2>
<p>bool 的文字为真或假。</p>
<h2 id="operations-1"><a class="header" href="#operations-1">Operations</a></h2>
<h3 id="logical"><a class="header" href="#logical">Logical</a></h3>
<p><code>bool</code> supports three logical operations:</p>
<h2 id="操作符"><a class="header" href="#操作符">操作符</a></h2>
<h3 id="逻辑的"><a class="header" href="#逻辑的">逻辑的</a></h3>
<p>bool 支持三种逻辑运算：</p>
<table><thead><tr><th>Syntax</th><th>Description</th><th>Equivalent Expression</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>short-circuiting logical and</td><td><code>p &amp;&amp; q</code> is equivalent to <code>if (p) q else false</code></td></tr>
<tr><td><code>||</code></td><td>short-circuiting logical or</td><td><code>p || q</code> is equivalent to <code>if (p) true else q</code></td></tr>
<tr><td><code>!</code></td><td>logical negation</td><td><code>!p</code> is equivalent to <code>if (p) false else true</code></td></tr>
</tbody></table>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p><code>bool</code> values are used in several of Move's control-flow constructs:</p>
<h3 id="控制流"><a class="header" href="#控制流">控制流</a></h3>
<p>布尔值用于 Move 的多个控制流结构中：</p>
<ul>
<li><a href="./conditionals.html"><code>if (bool) { ... }</code></a></li>
<li><a href="./loops.html"><code>while (bool) { .. }</code></a></li>
<li><a href="./abort-and-assert.html"><code>assert!(bool, u64)</code></a></li>
</ul>
<h2 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, boolean values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
<a href="./variables.html#move-and-copy"><code>copy</code></a>.</p>
<h2 id="所有权-1"><a class="header" href="#所有权-1">所有权</a></h2>
<p>与语言内置的其他标量值一样，布尔值是隐式可复制的，这意味着它们可以在没有显式指令（如复制）的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="地址"><a class="header" href="#地址">地址</a></h1>
<p><code>地址（address）</code>是 Move 中的内置类型，用于表示全局存储中的的位置（有时称为账户）。<code>地址（address）</code> 值是一个 128 位（16 字节）标识符。在一个给定的地址，可以存储两样东西：<a href="./modules-and-scripts.html">模块（Module）</a>和<a href="./structs-and-resources.html">资源（Resources）</a>。</p>
<p>虽然<code>地址（address）</code>在底层是一个 128 位整数，但 Move 语言有意让其不透明 —— 它们不能从整数创建，不支持算术运算，也不能修改。即使可能有一些有趣的程序会使用这种特性（例如，C 中的指针算法实现了类似壁龛（niche）的功能），但 Move 语言不允许这种动态行为，因为它从头开始就被设计为支持静态验证。<em>（壁龛指安装在墙壁上的小格子或在墙身上留出的作为贮藏设施的空间，最早在宗教上是指排放佛像的小空间，现在多用在家庭装修上，因其不占建筑面积，使用比较方便，深受大家喜爱，Joe 注）</em></p>
<p>你可以通过运行时地址值（<code>address</code> 类型的值）来访问该地址处的资源。但<em>无法</em>在运行时通过地址值访问模块。</p>
<h2 id="地址及其语法"><a class="header" href="#地址及其语法">地址及其语法</a></h2>
<p>地址有两种形式：<em>命名的</em>或<em>数值的</em>。命名地址的语法遵循 Move 命名标识符的规则。数值地址的语法不受十六进制编码值的限制，任何有效的 <a href="./integers.html"><code>u128</code> 数值</a>都可以用作地址值。例如，<code>42</code>，<code>0xCFAE</code> 和 <code>2021</code> 都是合法有效的数值地址字面量（literal）。</p>
<p>为了区分何时在表达式上下文中使用地址，使用地址时的语法根据使用地址的上下文而有所不同：</p>
<ul>
<li>当地址被用作表达式时，地址必须以 <code>@</code> 字符为前缀，例如：<a href="./integers.html"><code>@&lt;numerical_value&gt;</code></a> 或 <code>@&lt;named_address_identifier&gt;</code>。</li>
<li>在表达式上下文之外，地址可以不带前缀字符 <code>@</code>。例如：<a href="./integers.html"><code>&lt;numerical_value&gt;</code></a> 或 <code>&lt;named_address_identifier&gt;</code>。</li>
</ul>
<p>通常，可以将 <code>@</code> 视为将地址从命名空间项变为表达式项的运算符。</p>
<h2 id="命名地址"><a class="header" href="#命名地址">命名地址</a></h2>
<p>命名地址是一项特性，它允许在使用地址的任何地方使用标识符代替数值，而不仅仅是在值级别。命名地址被声明并绑定为 Move 包中的顶级元素（模块和脚本之外）或作为参数传递给 Move 编译器。</p>
<p>命名地址仅存在于源语言级别，并将在字节码级别完全替代它们的值。因此，模块和模块成员<em>必须</em>通过模块的命名地址而不是编译期间分配给命名地址的数值来访问，例如：<code>use my_addr::foo</code> <em>不等于</em> <code>use 0x2::foo</code>，即使 Move 程序编译时将 <code>my_addr</code> 设置成 <code>0x2</code>。这个区别在<a href="./modules-and-scripts.html">模块和脚本</a>一节中有更详细的讨论。</p>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<pre><code class="language-move">let a1: address = @0x1; // 0x00000000000000000000000000000001 的缩写
let a2: address = @0x42; // 0x00000000000000000000000000000042 的缩写
let a3: address = @0xDEADBEEF; // 0x000000000000000000000000DEADBEEF 的缩写
let a4: address = @0x0000000000000000000000000000000A;
let a5: address = @std; // 将命名地址 `std` 的值赋给 `a5`
let a6: address = @66;
let a7: address = @0x42;

module 66::some_module {   // 不在表达式上下文中，所以不需要 @
    use 0x1::other_module; // 不在表达式上下文中，所以不需要 @
    use std::vector;       // 使用其他模块时，可以使用命名地址作为命名空间项
    ...
}

module std::other_module {  // 可以使用命名地址作为命名空间项来声明模块
    ...
}
</code></pre>
<h2 id="全局存储操作"><a class="header" href="#全局存储操作">全局存储操作</a></h2>
<p><code>address</code> 值主要用来与全局存储操作进行交互。</p>
<p><code>address</code> 值与 <code>exists</code>、<code>borrow_global</code>、<code>borrow_global_mut</code> 和 <code>move_from</code> <a href="./global-storage-operators.html">操作（operation）</a>一起使用。</p>
<p>唯一<em>不使用</em> <code>address</code> 的全局存储操作是 <code>move_to</code>，它使用了 <a href="./signer.html"><code>signer</code></a>。</p>
<h2 id="所有权-2"><a class="header" href="#所有权-2">所有权</a></h2>
<p>与 Move 语言内置的其他标量值一样，<code>address</code> 值是隐式可复制的，这意味着它们可以在没有显式指令（例如 <a href="./variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a>）的情况下复制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="向量"><a class="header" href="#向量">向量</a></h1>
<p><code>vector&lt;T&gt;</code> 是 Move 提供的唯一原始集合类型。<code>vector&lt;T&gt;</code> 是类型为 <code>T</code> 的同构集合，可以通过从&quot;末端&quot;推入/弹出（出栈/入栈，译者注）值来增长或缩小。
<em>（与 Rust 一样，向量（vector）是一种可以存放任何类型的可变大小的容器，也可称为<a href="https://en.wikipedia.org/wiki/Dynamic_array">动态数组</a>，与 Python 中的<a href="https://computersciencewiki.org/index.php/Lists">列表（list）</a>不同，译者注）</em></p>
<p><code>vector&lt;T&gt;</code> 可以用任何类型 <code>T</code> 实例化。例如，<code>vector&lt;u64&gt;</code>、<code>vector&lt;address&gt;</code>、<code>vector&lt;0x42::MyModuel::MyResource&gt;</code> 和 <code>vector&lt;vector&lt;u8&gt;&gt;</code> 都是有效的向量类型。</p>
<h2 id="字面量-2"><a class="header" href="#字面量-2">字面量</a></h2>
<h3 id="通用-vector-字面量"><a class="header" href="#通用-vector-字面量">通用 <code>vector</code> 字面量</a></h3>
<p>任何类型的向量都可以通过 <code>vector</code> 字面量创建。</p>
<table><thead><tr><th>语法</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>vector[]</code></td><td><code>vector[]: vector&lt;T&gt;</code> 其中 <code>T</code> 是任何单一的非引用类型</td><td>一个空向量</td></tr>
<tr><td><code>vector[e1, ..., en]</code></td><td><code>vector[e1, ..., en]: vector&lt;T&gt;</code> where <code>e_i: T</code> 满足 <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>带有 <code>n</code> 个元素（长度为 n）的向量</td></tr>
</tbody></table>
<p>在这些情况下，<code>vector</code> 的类型是从元素类型或从向量的使用上推断出来的。如果无法推断类型或者只是为了更清楚地表示，则可以显式指定类型：</p>
<pre><code class="language-move">vector&lt;T&gt;[]: vector&lt;T&gt;
vector&lt;T&gt;[e1, ..., en]: vector&lt;T&gt;
</code></pre>
<h4 id="向量字面量示例"><a class="header" href="#向量字面量示例">向量字面量示例</a></h4>
<pre><code class="language-move">(vector[]: vector&lt;bool&gt;);
(vector[0u8, 1u8, 2u8]: vector&lt;u8&gt;);
(vector&lt;u128&gt;[]: vector&lt;u128&gt;);
(vector&lt;address&gt;[@0x42, @0x100]: vector&lt;address&gt;);
</code></pre>
<h3 id="vectoru8-字面量"><a class="header" href="#vectoru8-字面量"><code>vector&lt;u8&gt;</code> 字面量</a></h3>
<p>Move 中向量的一个常见用例是表示“字节数组”，用 <code>vector&lt;u8&gt;</code> 表示。这些值通常用于加密目的，例如公钥或哈希结果。这些值非常常见，以至于提供了特定的语法以使值更具可读性，而不是必须使用 <code>vector[]</code>，其中每个单独的 <code>u8</code> 值都以数字形式指定。</p>
<p>目前支持两种类型的 <code>vector&lt;u8&gt;</code> 字面量，<em>字节字符串</em>和<em>十六进制字符串</em>。</p>
<h4 id="字节字符串"><a class="header" href="#字节字符串">字节字符串</a></h4>
<p>字节字符串是带引号的字符串字面量，以 <code>b</code> 为前缀，例如，<code>b&quot;Hello!\n&quot;</code>。</p>
<p>这些是允许转义序列的 ASCII 编码字符串。目前，支持的转义序列如下：</p>
<table><thead><tr><th>转义序列</th><th>描述</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>换行</td></tr>
<tr><td><code>\r</code></td><td>回车</td></tr>
<tr><td><code>\t</code></td><td>制表符</td></tr>
<tr><td><code>\\</code></td><td>反斜杠</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
<tr><td><code>\&quot;</code></td><td>引号</td></tr>
<tr><td><code>\xHH</code></td><td>十六进制进制转义，插入十六进制字节序列 <code>HH</code></td></tr>
</tbody></table>
<h4 id="十六进制字符串"><a class="header" href="#十六进制字符串">十六进制字符串</a></h4>
<p>十六进制字符串是以 <code>x</code> 为前缀的带引号的字符串字面量，例如，<code>x&quot;48656C6C6F210A&quot;</code>。</p>
<p>每个字节对，范围从 <code>00</code> 到 <code>FF</code> 都被解析为十六进制编码的 <code>u8</code> 值。所以每个字节对对应于结果 <code>vector&lt;u8&gt;</code> 的单个条目。</p>
<h4 id="字符串字面量示例"><a class="header" href="#字符串字面量示例">字符串字面量示例</a></h4>
<pre><code class="language-move">script {
    fun byte_and_hex_strings() {
        assert!(b&quot;&quot; == x&quot;&quot;, 0);
        assert!(b&quot;Hello!\n&quot; == x&quot;48656C6C6F210A&quot;, 1);
        assert!(b&quot;\x48\x65\x6C\x6C\x6F\x21\x0A&quot; == x&quot;48656C6C6F210A&quot;, 2);
        assert!(
            b&quot;\&quot;Hello\tworld!\&quot;\n \r \\Null=\0&quot; ==
                x&quot;2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00&quot;,
            3
        );
    }
}
</code></pre>
<h2 id="操作"><a class="header" href="#操作">操作</a></h2>
<p><code>vector</code> 通过 Move 标准库里的 <code>std::vector</code> 模块支持以下操作：</p>
<table><thead><tr><th>函数</th><th>描述</th><th>中止条件</th></tr></thead><tbody>
<tr><td><code>vector::empty&lt;T&gt;(): vector&lt;T&gt;</code></td><td>创建一个可以存储 <code>T</code> 类型值的空向量</td><td>永不中止</td></tr>
<tr><td><code>vector::singleton&lt;T&gt;(t: T): vector&lt;T&gt;</code></td><td>创建一个包含 <code>t</code> 的大小为 1 的向量</td><td>永不中止</td></tr>
<tr><td><code>vector::push_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, t: T)</code></td><td>将 <code>t</code> 添加到 <code>v</code> 的尾部</td><td>永不中止</td></tr>
<tr><td><code>vector::pop_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): T</code></td><td>移除并返回 <code>v</code> 中的最后一个元素</td><td>如果 <code>v</code> 是空向量</td></tr>
<tr><td><code>vector::borrow&lt;T&gt;(v: &amp;vector&lt;T&gt;, i: u64): &amp;T</code></td><td>返回在索引 <code>i</code> 处对 <code>T</code> 的不可变引用</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::borrow_mut&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): &amp;mut T</code></td><td>返回在索引 <code>i</code> 处对 <code>T</code> 的可变引用</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::destroy_empty&lt;T&gt;(v: vector&lt;T&gt;)</code></td><td>销毁 <code>v</code> 向量</td><td>如果 <code>v</code> 不是空向量</td></tr>
<tr><td><code>vector::append&lt;T&gt;(v1: &amp;mut vector&lt;T&gt;, v2: vector&lt;T&gt;)</code></td><td>将 <code>v2</code> 中的元素添加到 <code>v1</code> 的末尾</td><td>永不中止</td></tr>
<tr><td><code>vector::contains&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): bool</code></td><td>如果 <code>e</code> 在向量 <code>v</code> 里返回 true，否则返回 false</td><td>永不中止</td></tr>
<tr><td><code>vector::swap&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64)</code></td><td>交换向量 <code>v</code> 中第 <code>i</code> 个和第 <code>j</code> 个索引处的元素</td><td>如果 <code>i</code> 或 <code>j</code> 越界</td></tr>
<tr><td><code>vector::reverse&lt;T&gt;(v: &amp;mut vector&lt;T&gt;)</code></td><td>反转向量 <code>v</code> 中元素的顺序</td><td>永不中止</td></tr>
<tr><td><code>vector::index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): (bool, u64)</code></td><td>如果 <code>e</code> 在索引 <code>i</code> 处的向量中，则返回 <code>(true, i)</code>。否则返回<code>(false, 0)</code></td><td>永不中止</td></tr>
<tr><td><code>vector::remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>移除向量 <code>v</code> 中的第 <code>i</code> 个元素，移动所有后续元素。这里的时间复杂度是 O(n)，并且保留了向量中元素的顺序</td><td>如果 <code>i</code> 越界</td></tr>
<tr><td><code>vector::swap_remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>将向量中的第 <code>i</code> 个元素与最后一个元素交换，然后弹出该元素。这里的时间复杂度是 O(1)，但是不保留向量中的元素顺序</td><td>如果 <code>i</code> 越界</td></tr>
</tbody></table>
<p>随着时间的推移可能会增加更多操作。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<pre><code class="language-move">use std::vector;

let v = vector::empty&lt;u64&gt;();
vector::push_back(&amp;mut v, 5);
vector::push_back(&amp;mut v, 6);

assert!(*vector::borrow(&amp;v, 0) == 5, 42);
assert!(*vector::borrow(&amp;v, 1) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 5, 42);
</code></pre>
<h2 id="销毁和复制-vector"><a class="header" href="#销毁和复制-vector">销毁和复制 <code>vector</code></a></h2>
<p><code>vector&lt;T&gt;</code> 的某些行为取决于元素类型 <code>T</code> 的能力（ability），例如：如果向量中包含不具有 <code>drop</code> 能力的元素，那么不能像上面例子中的 <code>v</code> 一样隐式丢弃 —— 它们必须用 <code>vector::destroy_empty</code> 显式销毁。</p>
<p>请注意，除非向量 <code>vec</code> 包含零个元素，否则 <code>vector::destroy_empty</code> 将在运行时中止：</p>
<pre><code class="language-move">fun destroy_any_vector&lt;T&gt;(vec: vector&lt;T&gt;) {
    vector::destroy_empty(vec) // 删除此行将导致编译器错误
}
</code></pre>
<p>但是删除包含带有 <code>drop</code> 能力的元素的向量不会发生错误：</p>
<pre><code class="language-move">fun destroy_droppable_vector&lt;T: drop&gt;(vec: vector&lt;T&gt;) {
    // 有效！
    // 不需要明确地做任何事情来销毁向量
}
</code></pre>
<p>同样，除非元素类型具有 <code>copy</code> 能力，否则无法复制向量。换句话说，当且仅当 <code>T</code> 具有 <code>copy</code> 能力时，<code>vector&lt;T&gt;</code> 才具有 <code>copy</code> 能力。然而，即使是可复制的向量也永远不会被隐式复制：</p>
<pre><code class="language-move">let x = vector::singleton&lt;u64&gt;(10);
let y = copy x; // 没有 copy 将导致编译器错误！
</code></pre>
<p>大向量的复制可能很昂贵，因此编译器需要显式 <code>copy</code> 以便更容易查看它们发生的位置。</p>
<p>有关更多详细信息，请参阅<a href="./abilities.html">类型能力</a>和<a href="./generics.html">泛型</a>部分。</p>
<h2 id="所有权-3"><a class="header" href="#所有权-3">所有权</a></h2>
<p><a href="vector.html#%E9%94%80%E6%AF%81%E5%92%8C%E5%A4%8D%E5%88%B6-vector">如上所述</a>，<code>vector</code> 值只有在元素值可以复制的时候才能复制。在这种情况下，复制必须通过显式 <a href="./variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a> 或者<a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">解引用 <code>*</code></a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="签名者"><a class="header" href="#签名者">签名者</a></h1>
<p><code>签名者（signer）</code>是 Move 内置的资源类型。<code>签名者（signer）</code>是一种允许持有者代表特定<code>地址（address）</code>行使权力的<a href="https://en.wikipedia.org/wiki/Object-capability_model">能力（capability）</a>。你可以将原生实现（native implementation）视为：</p>
<pre><code class="language-move">struct signer has drop { a: address }
</code></pre>
<p><code>signer</code> 有点像 Unix <a href="https://en.wikipedia.org/wiki/User_identifier">UID</a>，因为它表示一个通过 Move <em>之外</em>的代码（例如，通过检查加密签名或密码）进行身份验证的用户。</p>
<h2 id="与-address-的比较"><a class="header" href="#与-address-的比较">与 <code>address</code> 的比较</a></h2>
<p>Move 程序可以使用地址字面量（literal）创建任何<code>地址（address）</code>值，而无需特殊许可：</p>
<pre><code class="language-move">let a1 = @0x1;
let a2 = @0x2;
// ... 等等，所有其他可能的地址
</code></pre>
<p>但是，<code>signer</code> 值是特殊的，因为它们不能通过字面量或者指令创建 —— 只能通过 Move 虚拟机（VM）创建。在虚拟机运行带有 <code>signer</code> 类型参数的脚本之前，它会自动创建 <code>signer</code> 值并将它们传递给脚本：</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s: signer) {
        assert!(signer::address_of(&amp;s) == @0x42, 0);
    }
}
</code></pre>
<p>如果脚本是从 <code>0x42</code> 以外的任何地址发送的，则此脚本将中止并返回代码 <code>0</code>。</p>
<p>交易脚本可以有任意数量的 <code>signer</code>，只要 <code>signer</code> 参数排在其他参数前面。换句话说，所有 <code>signer</code> 参数都必须放在第一位。</p>
<pre><code class="language-move">script {
    use std::signer;
    fun main(s1: signer, s2: signer, x: u64, y: u8) {
        // ...
    }
}
</code></pre>
<p>这对于实现具有多方权限原子行为的*多重签名脚本（multi-signer scripts）*很有用。例如，上述脚本的扩展可以在 <code>s1</code> 和 <code>s2</code> 之间执行原子货币交换。</p>
<h2 id="signer-操作符"><a class="header" href="#signer-操作符"><code>signer</code> 操作符</a></h2>
<p><code>std::signer</code> 标准库模块为 <code>signer</code> 提供了两个实用函数：</p>
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td><code>signer::address_of(&amp;signer): address</code></td><td>返回由 <code>&amp;signer</code> 包装的地址值。</td></tr>
<tr><td><code>signer::borrow_address(&amp;signer): &amp;address</code></td><td>返回由 <code>&amp;signer</code> 包装的地址的引用。</td></tr>
</tbody></table>
<p>此外，<code>move_to&lt;T&gt;(&amp;signer, T)</code> <a href="./global-storage-operators.html">全局存储</a>操作符需要一个 <code>&amp;signer</code> 参数在 <code>signer.address</code> 的帐户下发布资源 <code>T</code>。这确保了只有经过身份验证的用户才能在其地址下发布资源。</p>
<h2 id="所有权-4"><a class="header" href="#所有权-4">所有权</a></h2>
<p>与简单的标量值不同，<code>signer</code> 值是不可复制的，这意味着他们不能被复制（通过任何操作，无论是通过显式 <a href="./variables.html#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><code>copy</code></a>指令还是通过<a href="./references.html#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5">解引用（dereference）<code>*</code></a>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<p>For more details on the rules of references, see <a href="./structs-and-resources.html">Structs and Resources</a></p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<p>Move 有两种类型的引用：不可变的 &amp; 和可变的 &amp;mut。不可变引用是只读的，不能修改基础值（或其任何字段）。可变引用允许通过写入该引用进行修改。 Move 的类型系统强制执行防止引用错误的所有权规则。</p>
<p>有关引用规则的更多详细信息，请参阅结构和资源</p>
<h2 id="reference-operators"><a class="header" href="#reference-operators">Reference Operators</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<h2 id="引用运算符"><a class="header" href="#引用运算符">引用运算符</a></h2>
<p>Move 提供了用于创建和扩展引用以及将可变引用转换为不可变引用的运算符。在这里和其他地方，我们使用符号 e: T 来表示“表达式 e 具有类型 T”。</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to
extend an existing reference:</p>
<p>&amp;e.f 和 &amp;mut e.f 运算符既可用于创建对结构的新引用，也可用于扩展现有引用：</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<p>只要两个结构都在同一个模块中，具有多个字段的引用表达式就可以工作：</p>
<pre><code class="language-move">struct A { b: B }
struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
  &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<p>最后，请注意，不允许引用引用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // will not compile
</code></pre>
<h2 id="reading-and-writing-through-references"><a class="header" href="#reading-and-writing-through-references">Reading and Writing Through References</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<h2 id="通过参考文献阅读和写作"><a class="header" href="#通过参考文献阅读和写作">通过参考文献阅读和写作</a></h2>
<p>可以读取可变和不可变引用以生成引用值的副本。</p>
<p>只能编写可变引用。写入 <code>*x = v</code> 会丢弃先前存储在 x 中的值并用 v 更新它。</p>
<p>这两个操作都使用类 C 的 <code>*</code> 语法。但是，请注意，读是一个表达式，而写是一个突变，必须发生在等号的左侧。</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
<p>In order for a reference to be read, the underlying type must have the
<a href="./abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:</p>
<p>为了读取引用，基础类型必须具有复制能力，因为读取引用会创建值的新副本。此规则防止复制资源值：</p>
<pre><code class="language-move=">fun copy_resource_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="./abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:
双重：为了写入引用，基础类型必须具有删除能力，因为写入引用将丢弃（或“删除”）旧值。此规则可防止破坏资源值：</p>
<pre><code class="language-move=">fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-inference"><a class="header" href="#freeze-inference"><code>freeze</code> inference</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<h2 id="冻结推理"><a class="header" href="#冻结推理">冻结推理</a></h2>
<p>可变引用可以在需要不可变引用的上下文中使用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;mut u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:
这是因为在底层，编译器会在需要的地方插入冻结指令。以下是冻结推理的更多示例：</p>
<pre><code class="language-move=">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<h3 id="子类型化"><a class="header" href="#子类型化">子类型化</a></h3>
<p>通过这种冻结推断，Move 类型检查器可以将 &amp;mut T 视为 &amp;T 的子类型。如上所示，这意味着对于任何使用 &amp;T 值的表达式，也可以使用 &amp;mut T 值。此术语用于错误消息中，以简明扼要地表明在提供 &amp;T 的情况下需要 &amp;mut T。例如</p>
<pre><code class="language-move=">address 0x42 {
module example {
    fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
        *store = *new_value
    }

    fun subtype_examples() {
        let x: &amp;u64 = &amp;0;
        let y: &amp;mut u64 = &amp;mut 1;

        x = &amp;mut 1; // valid
        y = &amp;2; // invalid!

        read_and_assign(y, x); // valid
        read_and_assign(x, y); // invalid!
    }
}
}
</code></pre>
<p>will yield the following error messages
将产生以下错误消息</p>
<pre><code class="language-text">error:

    ┌── example.move:12:9 ───
    │
 12 │         y = &amp;2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &amp;2; // invalid!
    │             -- The type: '&amp;{integer}'
    ·
  9 │         let y: &amp;mut u64 = &amp;mut 1;
    │                -------- Is not a subtype of: '&amp;mut u64'
    │

error:

    ┌── example.move:15:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let x: &amp;u64 = &amp;0;
    │                ---- The type: '&amp;u64'
    ·
  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
    │                                -------- Is not a subtype of: '&amp;mut u64'
    │
</code></pre>
<p>The only other types currently that has subtyping are <a href="./tuples.html">tuples</a></p>
<p>当前唯一具有子类型的其他类型是元组</p>
<h2 id="ownership-2"><a class="header" href="#ownership-2">Ownership</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<h2 id="所有权-5"><a class="header" href="#所有权-5">所有权</a></h2>
<p>即使存在相同引用的现有副本或扩展，可变引用和不可变引用也始终可以被复制和扩展：</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="./variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<p>对于熟悉 Rust 所有权系统的程序员来说，这可能会令人惊讶，因为他们会拒绝上面的代码。 Move 的类型系统在处理副本方面更加宽松，但在写入前确保可变引用的唯一所有权方面同样严格。</p>
<h3 id="references-cannot-be-stored"><a class="header" href="#references-cannot-be-stored">References Cannot Be Stored</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the <code>store</code> <a href="./abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>Currently, Move cannot support this because references cannot be
<a href="https://en.wikipedia.org/wiki/Serialization">serialized</a>, but <em>every Move value must be
serializable</em>. This requirement comes from Move's
<a href="./global-storage-structure.html">persistent global storage</a>, which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs <em>and</em> ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the <code>store</code> <a href="./abilities.html">ability</a>, but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.</p>
<h3 id="无法存储引用"><a class="header" href="#无法存储引用">无法存储引用</a></h3>
<p>引用和元组是唯一不能存储为结构的字段值的类型，这也意味着它们不能存在于全局存储中。当 Move 程序终止时，程序执行期间创建的所有引用都将被销毁；它们完全是短暂的。这个不变量对于没有存储能力的类型的值也是正确的，但请注意，引用和元组更进一步，因为从一开始就不允许在结构中。</p>
<p>这是 Move 和 Rust 之间的另一个区别，后者允许将引用存储在结构内。</p>
<p>目前，Move 无法支持这一点，因为引用无法序列化，但每个 Move 值都必须是可序列化的。这个需求来自于 Move 的持久化全局存储，它需要序列化值以在程序执行中持久化它们。结构可以写入全局存储，因此它们必须是可序列化的。</p>
<p>可以想象一种更奇特、更有表现力的类型系统，它允许将引用存储在结构中，并禁止这些结构存在于全局存储中。我们也许可以允许不具备存储能力的结构内部的引用，但这并不能完全解决问题：Move 有一个相当复杂的系统来跟踪静态引用安全，并且类型系统的这方面也必须扩展支持在结构内存储引用。简而言之，Move 的类型系统（尤其是与引用安全相关的方面）必须扩展以支持存储的引用。但随着语言的发展，我们一直在关注这一点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-and-unit"><a class="header" href="#tuples-and-unit">Tuples and Unit</a></h1>
<p>Move does not fully support tuples as one might expect coming from another language with them as a
first-class value. However, in order to support multiple return values, Move has tuple-like
expressions. These expressions do not result in a concrete value at runtime (there are no tuples in
the bytecode), and as a result they are very limited: they can only appear in expressions (usually
in the return position for a function); they cannot be bound to local variables; they cannot be
stored in structs; and tuple types cannot be used to instantiate generics.</p>
<p>Similarly, unit <code>()</code> is a type created by the Move source language in order to be expression based.
The unit value <code>()</code> does not result in any runtime value. We can consider unit<code>()</code> to be an empty
tuple, and any restrictions that apply to tuples also apply to unit.</p>
<p>It might feel weird to have tuples in the language at all given these restrictions. But one of the
most common use cases for tuples in other languages is for functions to allow functions to return
multiple values. Some languages work around this by forcing the users to write structs that contain
the multiple return values. However in Move, you cannot put references inside of
<a href="./structs-and-resources.html">structs</a>. This required Move to support multiple return values. These
multiple return values are all pushed on the stack at the bytecode level. At the source level, these
multiple return values are represented using tuples.</p>
<h1 id="元组和单元"><a class="header" href="#元组和单元">元组和单元</a></h1>
<p>Move 不完全支持元组，因为人们可能期望来自另一种语言的元组将它们作为一等值。但是，为了支持多个返回值，Move 具有类似元组的表达式。这些表达式在运行时不会产生具体的值（字节码中没有元组），因此它们非常有限：它们只能出现在表达式中（通常在函数的返回位置）；它们不能绑定到局部变量；它们不能存储在结构中；元组类型不能用于实例化泛型。</p>
<p>类似地，unit() 是 Move 源语言创建的一种类型，以便基于表达式。单位值 () 不会产生任何运行时值。我们可以认为 unit() 是一个空元组，适用于元组的任何限制也适用于 unit。</p>
<p>考虑到这些限制，在语言中使用元组可能会感觉很奇怪。但其他语言中元组最常见的用例之一是函数允许函数返回多个值。一些语言通过强制用户编写包含多个返回值的结构来解决这个问题。但是在 Move 中，您不能将引用放在结构中。这需要 Move 支持多个返回值。这些多个返回值都在字节码级别被压入堆栈。在源级别，这些多个返回值使用元组表示。</p>
<h2 id="literals-2"><a class="header" href="#literals-2">Literals</a></h2>
<p>Tuples are created by a comma separated list of expressions inside of parentheses</p>
<h2 id="字面量-3"><a class="header" href="#字面量-3">字面量</a></h2>
<p>元组由括号内的逗号分隔的表达式列表创建</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(): ()</code></td><td>Unit, the empty tuple, or the tuple of arity 0</td></tr>
<tr><td><code>(e1, ..., en)</code></td><td><code>(e1, ..., en): (T1, ..., Tn)</code> where <code>e_i: Ti</code> s.t. <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>A <code>n</code>-tuple, a tuple of arity <code>n</code>, a tuple with <code>n</code> elements</td></tr>
</tbody></table>
<p>Note that <code>(e)</code> does not have type <code>(e): (t)</code>, in other words there is no tuple with one element. If
there is only a single element inside of the parentheses, the parentheses are only used for
disambiguation and do not carry any other special meaning.</p>
<p>Sometimes, tuples with two elements are called &quot;pairs&quot; and tuples with three elements are called
&quot;triples.&quot;</p>
<p>注意 (e) 没有类型 (e): (t)，换句话说，没有一个元素的元组。如果括号内只有一个元素，则括号仅用于消歧，不带有任何其他特殊含义。</p>
<p>有时，具有两个元素的元组称为“对”，而具有三个元素的元组称为“三元组”。</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<h3 id="例子-2"><a class="header" href="#例子-2">例子</a></h3>
<pre><code class="language-move=">address 0x42 {
module example {
    // all 3 of these functions are equivalent

    // when no return type is provided, it is assumed to be `()`
    fun returs_unit_1() { }

    // there is an implicit () value in empty expression blocks
    fun returs_unit_2(): () { }

    // explicit version of `returs_unit_1` and `returs_unit_2`
    fun returs_unit_3(): () { () }


    fun returns_3_values(): (u64, bool, address) {
        (0, false, @0x42)
    }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) {
        (x, 0, 1, b&quot;foobar&quot;)
    }
}
}
</code></pre>
<h2 id="operations-2"><a class="header" href="#operations-2">Operations</a></h2>
<p>The only operation that can be done on tuples currently is destructuring.</p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>For tuples of any size, they can be destructured in either a <code>let</code> binding or in an assignment.</p>
<p>For example:</p>
<h2 id="运营-1"><a class="header" href="#运营-1">运营</a></h2>
<p>目前可以对元组进行的唯一操作是解构。</p>
<h3 id="解构"><a class="header" href="#解构">解构</a></h3>
<p>对于任何大小的元组，它们可以在 let 绑定或赋值中解构。</p>
<p>例如：</p>
<pre><code class="language-move=">address 0x42 {
module example {
    // all 3 of these functions are equivalent
    fun returns_unit() {}
    fun returns_2_values(): (bool, bool) { (true, false) }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) { (x, 0, 1, b&quot;foobar&quot;) }

    fun examples(cond: bool) {
        let () = ();
        let (x, y): (u8, u64) = (0, 1);
        let (a, b, c, d) = (@0x0, 0, false, b&quot;&quot;);

        () = ();
        (x, y) = if (cond) (1, 2) else (3, 4);
        (a, b, c, d) = (@0x1, 1, true, b&quot;1&quot;);
    }

    fun examples_with_function_calls() {
        let () = returns_unit();
        let (x, y): (bool, bool) = returns_2_values();
        let (a, b, c, d) = returns_4_values(&amp;0);

        () = returns_unit();
        (x, y) = returns_2_values();
        (a, b, c, d) = returns_4_values(&amp;1);
    }
}
}
</code></pre>
<p>For more details, see <a href="./variables.html">Move Variables</a>.
有关更多详细信息，请参阅移动变量。</p>
<h2 id="subtyping-1"><a class="header" href="#subtyping-1">Subtyping</a></h2>
<p>Along with references, tuples are the only types that have subtyping in Move. Tuples do have
subtyping only in the sense that subtype with references (in a covariant way).</p>
<p>For example</p>
<h2 id="子类型化-1"><a class="header" href="#子类型化-1">子类型化</a></h2>
<p>除了引用，元组是唯一在 Move 中具有子类型的类型。元组只有在具有引用的子类型（以协变方式）的意义上才具有子类型。</p>
<p>例如</p>
<pre><code class="language-move=">let x: &amp;u64 = &amp;0;
let y: &amp;mut u64 = &amp;mut 1;

// (&amp;u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
//   since &amp;mut u64 is a subtype of &amp;u64
let (a, b): (&amp;u64, &amp;u64) = (x, y);
// (&amp;mut u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
//   since &amp;mut u64 is a subtype of &amp;u64
let (c, d): (&amp;u64, &amp;u64) = (y, y);
// error! (&amp;u64, &amp;mut u64) is NOT a subtype of (&amp;mut u64, &amp;mut u64)
//   since &amp;u64 is NOT a subtype of &amp;mut u64
let (e, f): (&amp;mut u64, &amp;mut u64) = (x, y);
</code></pre>
<h2 id="ownership-3"><a class="header" href="#ownership-3">Ownership</a></h2>
<p>As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored
into local variables because of this (but it is likely that this feature will come soon). As such,
tuples can only be moved currently, as copying them would require putting them into a local variable
first.</p>
<h2 id="所有权-6"><a class="header" href="#所有权-6">所有权</a></h2>
<p>如上所述，元组值在运行时并不真正存在。由于这个原因，目前它们不能存储到局部变量中（但这个功能很可能很快就会出现）。因此，元组目前只能移动，因为复制它们需要先将它们放入局部变量中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-variables-and-scope"><a class="header" href="#local-variables-and-scope">Local Variables and Scope</a></h1>
<p>Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword <code>let</code>, which will shadow any previous local with the same name. Locals are mutable and can
be updated both directly and via a mutable reference.</p>
<h1 id="局部变量和范围"><a class="header" href="#局部变量和范围">局部变量和范围</a></h1>
<p>Move 中的局部变量是词法（静态）范围的。使用关键字 let 引入了新变量，这将隐藏任何以前的同名本地变量。局部变量是可变的，可以直接更新，也可以通过可变引用更新。</p>
<h2 id="declaring-local-variables"><a class="header" href="#declaring-local-variables">Declaring Local Variables</a></h2>
<h3 id="let-bindings"><a class="header" href="#let-bindings"><code>let</code> bindings</a></h3>
<p>Move programs use <code>let</code> to bind variable names to values:</p>
<h2 id="声明局部变量"><a class="header" href="#声明局部变量">声明局部变量</a></h2>
<h3 id="let-绑定"><a class="header" href="#let-绑定"><code>let</code> 绑定</a></h3>
<p>移动程序使用 let 将变量名绑定到值：</p>
<pre><code class="language-move">let x = 1;
let y = x + x:
</code></pre>
<p><code>let</code> can also be used without binding a value to the local.</p>
<p>let 也可以在不将值绑定到本地的情况下使用。</p>
<pre><code class="language-move">let x;
</code></pre>
<p>The local can then be assigned a value later.</p>
<p>然后可以稍后为本地分配一个值。</p>
<pre><code class="language-move">let x;
if (cond) {
  x = 1
} else {
  x = 0
}
</code></pre>
<p>This can be very helpful when trying to extract a value from a loop when a default value cannot be
provided.</p>
<p>当无法提供默认值时，这在尝试从循环中提取值时非常有用。</p>
<pre><code class="language-move">let x;
let cond = true;
let i = 0;
loop {
    (x, cond) = foo(i);
    if (!cond) break;
    i = i + 1;
}
</code></pre>
<h3 id="variables-must-be-assigned-before-use"><a class="header" href="#variables-must-be-assigned-before-use">Variables must be assigned before use</a></h3>
<p>Move's type system prevents a local variable from being used before it has been assigned.</p>
<h3 id="变量必须在使用前赋值"><a class="header" href="#变量必须在使用前赋值">变量必须在使用前赋值</a></h3>
<p>Move 的类型系统防止在分配之前使用局部变量。</p>
<pre><code class="language-move">let x;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
if (cond) x = 0;
x + x // ERROR!
</code></pre>
<pre><code class="language-move">let x;
while (cond) x = 0;
x + x // ERROR!
</code></pre>
<h3 id="valid-variable-names"><a class="header" href="#valid-variable-names">Valid variable names</a></h3>
<p>Variable names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, and digits <code>0</code>
to <code>9</code>. Variable names must start with either an underscore <code>_</code> or a letter <code>a</code> through <code>z</code>. They
<em>cannot</em> start with uppercase letters.</p>
<h3 id="有效的变量名"><a class="header" href="#有效的变量名">有效的变量名</a></h3>
<p>变量名称可以包含下划线 <code>_</code>、字母 a 到 z、字母 A 到 Z 以及数字 0 到 9。变量名称必须以下划线 <code>_</code> 或字母 a 到 z 开头。它们不能以大写字母开头。</p>
<pre><code class="language-move">// all valid
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// all invalid
let X = e; // ERROR!
let Foo = e; // ERROR!
</code></pre>
<h3 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h3>
<p>The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:</p>
<h3 id="类型注释"><a class="header" href="#类型注释">类型注释</a></h3>
<p>局部变量的类型几乎总是可以通过 Move 的类型系统推断出来。但是，Move 允许显式类型注释，这对可读性、清晰性或可调试性很有用。添加类型注释的语法是：</p>
<pre><code class="language-move">let x: T = e; // &quot;Variable x of type T is initialized to expression e&quot;
</code></pre>
<p>Some examples of explicit type annotations:</p>
<p>显式类型注释的一些示例：</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct S { f: u64, g: u64 }

    fun annotated() {
        let u: u8 = 0;
        let b: vector&lt;u8&gt; = b&quot;hello&quot;;
        let a: address = @0x0;
        let (x, y): (&amp;u64, &amp;mut u64) = (&amp;0, &amp;mut 1);
        let S { f, g: f2 }: S = S { f: 0, g: 1 };
    }
}
}
</code></pre>
<p>Note that the type annotations must always be to the right of the pattern:</p>
<p>请注意，类型注释必须始终位于模式的右侧：</p>
<pre><code class="language-move">let (x: &amp;u64, y: &amp;mut u64) = (&amp;0, &amp;mut 1); // ERROR! should be let (x, y): ... =
</code></pre>
<h3 id="when-annotations-are-necessary"><a class="header" href="#when-annotations-are-necessary">When annotations are necessary</a></h3>
<p>In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:</p>
<h3 id="需要注释时"><a class="header" href="#需要注释时">需要注释时</a></h3>
<p>在某些情况下，如果类型系统无法推断类型，则需要本地类型注释。当无法推断泛型类型的类型参数时，通常会发生这种情况。例如：</p>
<pre><code class="language-move">let _v1 = vector::empty(); // ERROR!
//        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation
let v2: vector&lt;u64&gt; = vector::empty(); // no error
</code></pre>
<p>In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both <code>return</code> and <a href="./abort-and-assert.html"><code>abort</code></a> are expressions
and can have any type. A <a href="./loops.html"><code>loop</code></a> has type <code>()</code> if it has a <code>break</code>, but if there is no
break out of the <code>loop</code>, it could have any type. If these types cannot be inferred, a type
annotation is required. For example, this code:</p>
<p>在极少数情况下，类型系统可能无法推断不同代码的类型（以下所有代码都无法访问）。 return 和 abort 都是表达式，可以有任何类型。如果循环有中断，则其类型为 ()，但如果循环没有中断，则它可以具有任何类型。如果无法推断出这些类型，则需要类型注释。例如，这段代码：</p>
<pre><code class="language-move">let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
</code></pre>
<p>Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.</p>
<p>在这段代码中添加类型注释会暴露其他关于死代码或未使用的局部变量的错误，但该示例仍然有助于理解这个问题。</p>
<h3 id="multiple-declarations-with-tuples"><a class="header" href="#multiple-declarations-with-tuples">Multiple declarations with tuples</a></h3>
<p><code>let</code> can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.</p>
<h3 id="带有元组的多个声明"><a class="header" href="#带有元组的多个声明">带有元组的多个声明</a></h3>
<p>let 可以使用元组一次引入多个本地。括号内声明的局部变量被初始化为元组中的相应值。</p>
<pre><code class="language-move">let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
</code></pre>
<p>The type of the expression must match the arity of the tuple pattern exactly.</p>
<p>表达式的类型必须与元组模式的数量完全匹配。</p>
<pre><code class="language-move">let (x, y) = (0, 1, 2); // ERROR!
let (x, y, z, q) = (0, 1, 2); // ERROR!
</code></pre>
<p>You cannot declare more than one local with the same name in a single <code>let</code>.
您不能在一个 let 中声明多个具有相同名称的本地。</p>
<pre><code class="language-move">let (x, x) = 0; // ERROR!
</code></pre>
<h3 id="multiple-declarations-with-structs"><a class="header" href="#multiple-declarations-with-structs">Multiple declarations with structs</a></h3>
<p><code>let</code> can also introduce more than one local at a time when destructuring (or matching against) a
struct. In this form, the <code>let</code> creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:</p>
<h3 id="带有结构的多个声明"><a class="header" href="#带有结构的多个声明">带有结构的多个声明</a></h3>
<p>let 还可以在解构（或匹配）结构时一次引入多个本地。在这种形式中，let 创建了一组局部变量，这些变量被初始化为结构中字段的值。语法如下所示：</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>Here is a more complicated example:</p>
<p>这是一个更复杂的例子：</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }
    struct Y { x1: X, x2: X }

    fun new_x(): X {
        X { f: 1 }
    }

    fun example() {
        let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
        assert!(f + x2.f == 2, 42);

        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
        assert!(f1 + f2 == 2, 42);
    }
}
}
</code></pre>
<p>Fields of structs can serve double duty, identifying the field to bind <em>and</em> the name of the
variable. This is sometimes referred to as punning.
结构的字段可以起到双重作用，识别要绑定的字段和变量的名称。这有时被称为双关语。</p>
<pre><code class="language-move">let X { f } = e;
</code></pre>
<p>is equivalent to:</p>
<p>相当于：</p>
<pre><code class="language-move">let X { f: f } = e;
</code></pre>
<p>As shown with tuples, you cannot declare more than one local with the same name in a single <code>let</code>.</p>
<p>如元组所示，您不能在单个 let 中声明多个具有相同名称的本地。</p>
<pre><code class="language-move">let Y { x1: x, x2: x } = e; // ERROR!
</code></pre>
<h3 id="destructuring-against-references"><a class="header" href="#destructuring-against-references">Destructuring against references</a></h3>
<p>In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.</p>
<h3 id="针对引用进行解构"><a class="header" href="#针对引用进行解构">针对引用进行解构</a></h3>
<p>在上面的结构示例中，let 中的绑定值被移动，破坏了结构值并绑定了它的字段。</p>
<pre><code class="language-move">struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>In this scenario the struct value <code>T { f1: 1, f2: 2 }</code> no longer exists after the <code>let</code>.</p>
<p>If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:
在这种情况下，结构值 T { f1: 1, f2: 2 } 在 let 之后不再存在。</p>
<p>如果您希望不移动和破坏结构值，则可以借用其每个字段。例如：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;t;
// local1: &amp;u64
// local2: &amp;u64
</code></pre>
<p>And similarly with mutable references:
与可变引用类似：</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;mut t;
// local1: &amp;mut u64
// local2: &amp;mut u64
</code></pre>
<p>This behavior can also work with nested structs.
此行为也适用于嵌套结构。</p>
<pre><code class="language-move">address 0x42 {
module example {
    struct X { f: u64 }
    struct Y { x1: X, x2: X }

    fun new_x(): X {
        X { f: 1 }
    }

    fun example() {
        let y = Y { x1: new_x(), x2: new_x() };

        let Y { x1: X { f }, x2 } = &amp;y;
        assert!(*f + x2.f == 2, 42);

        let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &amp;mut y;
        *f1 = *f1 + 1;
        *f2 = *f2 + 1;
        assert!(*f1 + *f2 == 4, 42);
    }
}
}
</code></pre>
<h3 id="ignoring-values"><a class="header" href="#ignoring-values">Ignoring Values</a></h3>
<p>In <code>let</code> bindings, it is often helpful to ignore some values. Local variables that start with <code>_</code>
will be ignored and not introduce a new variable</p>
<h3 id="忽略值"><a class="header" href="#忽略值">忽略值</a></h3>
<p>在 let 绑定中，忽略某些值通常很有帮助。以 _ 开头的局部变量将被忽略，不会引入新变量</p>
<pre><code class="language-move">fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
</code></pre>
<pre><code class="language-move">let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2)
</code></pre>
<p>This can be necessary at times as the compiler will error on unused local variables
这有时是必要的，因为编译器会在未使用的局部变量上出错</p>
<pre><code class="language-move">let (x1, y, z1) = three(); // ERROR!
//       ^ unused local 'y'
</code></pre>
<h3 id="general-let-grammar"><a class="header" href="#general-let-grammar">General <code>let</code> grammar</a></h3>
<p>All of the different structures in <code>let</code> can be combined! With that we arrive at this general
grammar for <code>let</code> statements:</p>
<h3 id="一般-let-语法"><a class="header" href="#一般-let-语法">一般 <code>let</code> 语法</a></h3>
<p>let 中所有不同的结构都可以组合！这样，我们就得出了 let 语句的一般语法：</p>
<blockquote>
<p><em>let-binding</em> → <strong>let</strong> <em>pattern-or-list</em> <em>type-annotation</em><sub><em>opt</em></sub>
<em>initializer</em><sub><em>opt</em></sub> &gt; <em>pattern-or-list</em> → <em>pattern</em> | <strong>(</strong> <em>pattern-list</em> <strong>)</strong> &gt;
<em>pattern-list</em> → <em>pattern</em> <strong>,</strong><sub><em>opt</em></sub> | <em>pattern</em> <strong>,</strong> <em>pattern-list</em> &gt;
<em>type-annotation</em> → <strong>:</strong> <em>type</em> <em>initializer</em> → <strong>=</strong> <em>expression</em></p>
</blockquote>
<p>The general term for the item that introduces the bindings is a <em>pattern</em>. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:</p>
<p>引入绑定的项目的通用术语是模式。该模式用于解构数据（可能是递归的）并引入绑定。模式语法如下：</p>
<blockquote>
<p><em>pattern</em> → <em>local-variable</em> | <em>struct-type</em> <strong>{</strong> <em>field-binding-list</em> <strong>}</strong> &gt;
<em>field-binding-list</em> → <em>field-binding</em> <strong>,</strong><sub><em>opt</em></sub> | <em>field-binding</em> <strong>,</strong>
<em>field-binding-list</em> &gt; <em>field-binding</em> → <em>field</em> | <em>field</em> <strong>:</strong> <em>pattern</em></p>
</blockquote>
<p>A few concrete examples with this grammar applied:</p>
<p>应用此语法的一些具体示例：</p>
<pre><code class="language-move">    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable
//       ^                           pattern
//          ^                        local-variable
//          ^                        pattern
//          ^                        pattern-list
//       ^^^^                        pattern-list
//      ^^^^^^                       pattern-or-list
//            ^^^^^^^^^^^^           type-annotation
//                         ^^^^^^^^  initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type
//            ^                                field
//            ^                                field-binding
//               ^                             field
//                  ^                          local-variable
//                  ^                          pattern
//               ^^^^                          field-binding
//            ^^^^^^^                          field-binding-list
//      ^^^^^^^^^^^^^^^                        pattern
//      ^^^^^^^^^^^^^^^                        pattern-or-list
//                      ^^^^^^^^^^^^^^^^^^^^   initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
</code></pre>
<h2 id="mutations"><a class="header" href="#mutations">Mutations</a></h2>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>After the local is introduced (either by <code>let</code> or as a function parameter), the local can be
modified via an assignment:</p>
<h2 id="突变"><a class="header" href="#突变">突变</a></h2>
<h3 id="作业"><a class="header" href="#作业">作业</a></h3>
<p>在引入局部后（通过 let 或作为函数参数），可以通过赋值来修改局部：</p>
<pre><code class="language-move">x = e
</code></pre>
<p>Unlike <code>let</code> bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always <code>()</code>.</p>
<p>与 let 绑定不同，赋值是表达式。在某些语言中，赋值返回被赋值的值，但在 Move 中，任何赋值的类型始终是 ()。</p>
<pre><code class="language-move">(x = e: ())
</code></pre>
<p>Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (<code>{</code>...<code>}</code>).
实际上，赋值是表达式意味着它们可以在不添加带有大括号 ({...}) 的新表达式块的情况下使用。</p>
<pre><code class="language-move">let x = 0;
if (cond) x = 1 else x = 2;
</code></pre>
<p>The assignment uses the same pattern syntax scheme as <code>let</code> bindings:</p>
<p>赋值使用与 let 绑定相同的模式语法方案：</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // This example will complain about unused variables and assignments.
    fun example() {
       let (x, _, z) = (0, 1, 3);
       let (x, y, f, g);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);
    }
}
}
</code></pre>
<p>Note that a local variable can only have one type, so the type of the local cannot change between
assignments.
注意一个局部变量只能有一种类型，所以局部变量的类型不能在赋值之间改变。</p>
<pre><code class="language-move">let x;
x = 0;
x = false; // ERROR!
</code></pre>
<h3 id="mutating-through-a-reference"><a class="header" href="#mutating-through-a-reference">Mutating through a reference</a></h3>
<p>In addition to directly modifying a local with assignment, a local can be modified via a mutable
reference <code>&amp;mut</code>.</p>
<h3 id="通过引用进行变异"><a class="header" href="#通过引用进行变异">通过引用进行变异</a></h3>
<p>除了通过赋值直接修改局部外，还可以通过可变引用 &amp;mut 修改局部。</p>
<pre><code class="language-move">let x = 0;
let r = &amp;mut x;
*r = 1;
assert!(x == 1, 42)
}
</code></pre>
<p>This is particularly useful if either:</p>
<p>(1) You want to modify different variables depending on some condition.</p>
<p>这在以下情况下特别有用：</p>
<p>(1) 您想根据某些条件修改不同的变量。</p>
<pre><code class="language-move">let x = 0;
let y = 1;
let r = if (cond) &amp;mut x else &amp;mut y;
*r = *r + 1;
</code></pre>
<p>(2) You want another function to modify your local value.</p>
<p>(2) 你想要另一个函数来修改你的本地值。</p>
<pre><code class="language-move">let x = 0;
modify_ref(&amp;mut x);
</code></pre>
<p>This sort of modification is how you modify structs and vectors!</p>
<p>这种修改就是你修改结构和向量的方式！</p>
<pre><code class="language-move">let v = vector::empty();
vector::push_back(&amp;mut v, 100);
assert!(*vector::borrow(&amp;v, 0) == 100, 42)
</code></pre>
<p>For more details, see <a href="./references.html">Move references</a>.</p>
<p>有关更多详细信息，请参阅移动引用。</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>Any local declared with <code>let</code> is available for any subsequent expression, <em>within that scope</em>.
Scopes are declared with expression blocks, <code>{</code>...<code>}</code>.</p>
<p>Locals cannot be used outside of the declared scope.</p>
<h2 id="范围"><a class="header" href="#范围">范围</a></h2>
<p>使用 let 声明的任何本地表达式都可用于该范围内的任何后续表达式。范围用表达式块声明，{...}。</p>
<p>局部变量不能在声明的范围之外使用。</p>
<pre><code class="language-move">let x = 0;
{
    let y = 1;
};
x + y // ERROR!
//  ^ unbound local 'y'
</code></pre>
<p>But, locals from an outer scope <em>can</em> be used in a nested scope.</p>
<p>但是，来自外部作用域的本地变量可以在嵌套作用域中使用。</p>
<pre><code class="language-move">{
    let x = 0;
    {
        let y = x + 1; // valid
    }
}
</code></pre>
<p>Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.</p>
<p>局部变量可以在可以访问的任何范围内进行变异。无论执行突变的范围如何，该突变都会在本地生存。</p>
<pre><code class="language-move">let x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
</code></pre>
<h3 id="expression-blocks"><a class="header" href="#expression-blocks">Expression Blocks</a></h3>
<p>An expression block is a series of statements separated by semicolons (<code>;</code>). The resulting value of
an expression block is the value of the last expression in the block.</p>
<h3 id="表达式块"><a class="header" href="#表达式块">表达式块</a></h3>
<p>表达式块是由分号 (;) 分隔的一系列语句。表达式块的结果值是块中最后一个表达式的值。</p>
<pre><code class="language-move">{ let x = 1; let y = 1; x + y }
</code></pre>
<p>In this example, the result of the block is <code>x + y</code>.</p>
<p>A statement can be either a <code>let</code> declaration or an expression. Remember that assignments (<code>x = e</code>)
are expressions of type <code>()</code>.</p>
<p>在此示例中，块的结果是 x + y。</p>
<p>语句可以是 let 声明或表达式。请记住，赋值 (x = e) 是 () 类型的表达式。</p>
<pre><code class="language-move">{ let x; let y = 1; x = 1; x + y }
</code></pre>
<p>Function calls are another common expression of type <code>()</code>. Function calls that modify data are
commonly used as statements.</p>
<p>函数调用是类型 () 的另一种常见表达方式。修改数据的函数调用通常用作语句。</p>
<pre><code class="language-move">{ let v = vector::empty(); vector::push_back(&amp;mut v, 1); v }
</code></pre>
<p>This is not just limited to <code>()</code> types---any expression can be used as a statement in a sequence!</p>
<p>这不仅限于 () 类型——任何表达式都可以用作序列中的语句！</p>
<pre><code class="language-move">{
    let x = 0;
    x + 1; // value is discarded
    x + 2; // value is discarded
    b&quot;hello&quot;; // value is discarded
}
</code></pre>
<p>But! If the expression contains a resource (a value without the <code>drop</code> <a href="./abilities.html">ability</a>),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the <code>drop</code> <a href="./abilities.html">ability</a>. (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)</p>
<p>但！如果表达式包含资源（没有丢弃能力的值），您将收到错误消息。这是因为 Move 的类型系统保证任何被删除的值都具有删除能力。 （必须转移所有权，或者必须在其声明模块中显式销毁该值。）</p>
<pre><code class="language-move">{
    let x = 0;
    Coin { value: x }; // ERROR!
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability
    x
}
</code></pre>
<p>If a final expression is not present in a block---that is, if there is a trailing semicolon <code>;</code>,
there is an implicit unit <code>()</code> value. Similarly, if the expression block is empty, there is an
implicit unit <code>()</code> value.</p>
<p>如果块中不存在最终表达式——也就是说，如果有一个尾随分号;，则有一个隐含的 unit () 值。同样，如果表达式块为空，则存在隐含的 unit() 值。</p>
<pre><code class="language-move">// Both are equivalent
// 两者是等价的
{ x = x + 1; 1 / x; }
{ x = x + 1; 1 / x; () }
</code></pre>
<pre><code class="language-move">// Both are equivalent
{ }
{ () }
</code></pre>
<p>An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)
表达式块本身就是一个表达式，可以在任何使用表达式的地方使用。 （注意：函数体也是一个表达式块，但函数体不能被另一个表达式代替。）</p>
<pre><code class="language-move">let my_vector: vector&lt;vector&lt;u8&gt;&gt; = {
    let v = vector::empty();
    vector::push_back(&amp;mut v, b&quot;hello&quot;);
    vector::push_back(&amp;mut v, b&quot;goodbye&quot;);
    v
};
</code></pre>
<p>(The type annotation is not needed in this example and only added for clarity.)
（此示例中不需要类型注释，只是为了清楚起见而添加。）</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>If a <code>let</code> introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called <em>shadowing</em>.</p>
<h3 id="隐藏"><a class="header" href="#隐藏">隐藏</a></h3>
<p>如果一个 let 引入了一个名称已经在作用域中的局部变量，则该作用域的其余部分将无法再访问先前的变量。这称为隐藏。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = 1; // x is shadowed
assert!(x == 1, 42);
</code></pre>
<p>When a local is shadowed, it does not need to retain the same type as before.</p>
<p>当局部被遮蔽时，它不需要保留与以前相同的类型。</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = b&quot;hello&quot;; // x is shadowed
assert!(x == b&quot;hello&quot;, 42);
</code></pre>
<p>After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
<a href="./abilities.html"><code>drop</code> ability</a>, as ownership of the value must be transferred by the end of the
function.</p>
<p>在本地被遮蔽后，存储在本地的值仍然存在，但将不再可访问。对于没有删除能力的类型的值，请记住这一点很重要，因为值的所有权必须在函数结束时转移。</p>
<pre><code class="language-move">address 0x42 {
    module example {
        struct Coin has store { value: u64 }

        fun unused_resource(): Coin {
            let x = Coin { value: 0 }; // ERROR!
//              ^ This local still contains a value without the `drop` ability
            x.value = 1;
            let x = Coin { value: 10 };
            x
//          ^ Invalid return
        }
    }
}
</code></pre>
<p>When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.
当本地在范围内被遮蔽时，该遮蔽仅保留在该范围内。一旦该范围结束，阴影就消失了。</p>
<pre><code class="language-move">let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
</code></pre>
<p>Remember, locals can change type when they are shadowed.</p>
<p>请记住，本地人在被遮蔽时可以更改类型。</p>
<pre><code class="language-move">let x = 0;
{
    let x = b&quot;hello&quot;;
    assert!(x = b&quot;hello&quot;, 42);
};
assert!(x == 0, 42);
</code></pre>
<h2 id="move-and-copy"><a class="header" href="#move-and-copy">Move and Copy</a></h2>
<p>All local variables in Move can be used in two ways, either by <code>move</code> or <code>copy</code>. If one or the other
is not specified, the Move compiler is able to infer whether a <code>copy</code> or a <code>move</code> should be used.
This means that in all of the examples above, a <code>move</code> or a <code>copy</code> would be inserted by the
compiler. A local variable cannot be used without the use of <code>move</code> or <code>copy</code>.</p>
<p><code>copy</code> will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With <code>copy</code>, the local
variable can be used more than once.</p>
<h2 id="移动和复制"><a class="header" href="#移动和复制">移动和复制</a></h2>
<p>Move 中的所有局部变量都可以通过两种方式使用，通过移动或复制。如果未指定其中之一，则 Move 编译器能够推断应该使用副本还是移动。这意味着在上述所有示例中，编译器将插入移动或复制。如果不使用移动或复制，就不能使用局部变量。</p>
<p>复制可能会让人感觉最熟悉来自其他编程语言，因为它会在变量内部创建一个新的值副本以在该表达式中使用。使用复制，可以多次使用局部变量。</p>
<pre><code class="language-move">let x = 0;
let y = copy x + 1;
let z = copy x + 2;
</code></pre>
<p>Any value with the <code>copy</code> <a href="./abilities.html">ability</a> can be copied in this way.</p>
<p><code>move</code> takes the value out of the local variable <em>without</em> copying the data. After a <code>move</code> occurs,
the local variable is unavailable.</p>
<p>任何具有复制能力的值都可以通过这种方式复制。</p>
<p>move 从局部变量中取出值而不复制数据。移动发生后，局部变量不可用。</p>
<pre><code class="language-move">let x = 1;
let y = move x + 1;
//      ------ Local was moved here
let z = move x + 2; // Error!
//      ^^^^^^ Invalid usage of local 'x'
y + z
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in <a href="variables.html#let-bindings"><code>let</code> declaration</a> that prevents local variables from being used
before it is assigned a value.</p>
<h3 id="安全"><a class="header" href="#安全">安全</a></h3>
<p>Move 的类型系统会阻止一个值在移动后被使用。这与 let 声明中描述的安全检查相同，可防止在为其赋值之前使用局部变量。</p>
<!-- For more information, see TODO future section on ownership and move semantics. -->
<h3 id="inference"><a class="header" href="#inference">Inference</a></h3>
<p>As mentioned above, the Move compiler will infer a <code>copy</code> or <code>move</code> if one is not indicated. The
algorithm for doing so is quite simple:</p>
<ul>
<li>Any scalar value with the <code>copy</code> <a href="./abilities.html">ability</a> is given a <code>copy</code>.</li>
<li>Any reference (both mutable <code>&amp;mut</code> and immutable <code>&amp;</code>) is given a <code>copy</code>.
<ul>
<li>Except under special circumstances where it is made a <code>move</code> for predictable borrow checker
errors.</li>
</ul>
</li>
<li>Any other value is given a <code>move</code>.
<ul>
<li>This means that even though other values might be have the <code>copy</code> <a href="./abilities.html">ability</a>, it
must be done <em>explicitly</em> by the programmer.</li>
<li>This is to prevent accidental copies of large data structures.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<h3 id="推理"><a class="header" href="#推理">推理</a></h3>
<p>如上所述，如果未指明，Move 编译器将推断出副本或移动。这样做的算法非常简单：</p>
<ul>
<li>任何具有复制能力的标量值都会被赋予一个副本。</li>
<li>任何引用（可变的 &amp;mut 和不可变的 &amp;）都会给出一个副本。
<ul>
<li>除非在特殊情况下会因可预测的借用检查器错误而采取行动。</li>
</ul>
</li>
<li>任何其他值都会被移动。
<ul>
<li>这意味着即使其他值可能具有复制能力，也必须由程序员明确完成。</li>
<li>这是为了防止意外复制大型数据结构。
例如：</li>
</ul>
</li>
</ul>
<pre><code class="language-move">let s = b&quot;hello&quot;;
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };

let s2 = s; // move
let foo2 = foo; // move
let coin2 = coin; // move

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &amp;x;
let coin_ref = &amp;mut coin2;

let x2 = x; // copy
let b2 = b; // copy
let addr2 = @0x42; // copy
let x_ref2 = x_ref; // copy
let coin_ref2 = coin_ref; // copy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality-1"><a class="header" href="#equality-1">Equality</a></h1>
<p>Move supports two equality operations <code>==</code> and <code>!=</code></p>
<h1 id="平等-1"><a class="header" href="#平等-1">平等</a></h1>
<p>Move 支持两个相等操作 == 和 !=</p>
<h2 id="operations-3"><a class="header" href="#operations-3">Operations</a></h2>
<h2 id="操作符-1"><a class="header" href="#操作符-1">操作符</a></h2>
<table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td><td>Returns <code>true</code> if the two operands have the same value, <code>false</code> otherwise</td></tr>
<tr><td><code>!=</code></td><td>not equal</td><td>Returns <code>true</code> if the two operands have different values, <code>false</code> otherwise</td></tr>
</tbody></table>
<h3 id="typing"><a class="header" href="#typing">Typing</a></h3>
<p>Both the equal (<code>==</code>) and not-equal (<code>!=</code>) operations only work if both operands are the same type</p>
<h3 id="打字"><a class="header" href="#打字">打字</a></h3>
<p>相等 (==) 和不相等 (!=) 操作仅在两个操作数为相同类型时才有效</p>
<pre><code class="language-move">0 == 0; // `true`
1u128 == 2u128; // `false`
b&quot;hello&quot; != x&quot;00&quot;; // `true`
</code></pre>
<p>Equality and non-equality also work over user defined types!</p>
<p>相等和不相等也适用于用户定义的类型！</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct S has copy, drop { f: u64, s: vector&lt;u8&gt; }

    fun always_true(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        // parens are not needed but added for clarity in this example
        (copy s) == s
    }

    fun always_false(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        // parens are not needed but added for clarity in this example
        (copy s) != s
    }
}
}
</code></pre>
<p>If the operands have different types, there is a type checking error</p>
<p>如果操作数具有不同的类型，则存在类型检查错误</p>
<pre><code class="language-move">1u8 == 1u128; // ERROR!
//     ^^^^^ expected an argument of type 'u8'
b&quot;&quot; != 0; // ERROR!
//     ^ expected an argument of type 'vector&lt;u8&gt;'
</code></pre>
<h3 id="typing-with-references"><a class="header" href="#typing-with-references">Typing with references</a></h3>
<p>When comparing <a href="./references.html">references</a>, the type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable <code>&amp;</code> reference with a mutable one <code>&amp;mut</code> of
the same underlying type.</p>
<h3 id="使用参考打字"><a class="header" href="#使用参考打字">使用参考打字</a></h3>
<p>比较引用时，引用的类型（不可变或可变）无关紧要。这意味着您可以将不可变的 &amp; 引用与相同基础类型的可变 &amp;mut 进行比较。</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>The above is equivalent to applying an explicit freeze to each mutable reference where needed</p>
<p>以上相当于在需要时对每个可变引用应用显式冻结</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>But again, the underlying type must be the same type</p>
<p>但同样，基础类型必须是相同的类型</p>
<pre><code class="language-move">let i = &amp;0;
let s = &amp;b&quot;&quot;;

i == s; // ERROR!
//   ^ expected an argument of type '&amp;u64'
</code></pre>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>Both <code>==</code> and <code>!=</code> consume the value when comparing them. As a result, the type system enforces that
the type must have <a href="./abilities.html"><code>drop</code></a>. Recall that without the
<a href="./abilities.html"><code>drop</code> ability</a>, ownership must be transferred by the end of the function, and such
values can only be explicitly destroyed within their declaring module. If these were used directly
with either equality <code>==</code> or non-equality <code>!=</code>, the value would be destroyed which would break
<a href="./abilities.html"><code>drop</code> ability</a> safety guarantees!</p>
<h2 id="限制"><a class="header" href="#限制">限制</a></h2>
<p>== 和 != 在比较它们时都会消耗值。结果，类型系统强制该类型必须具有 drop。回想一下，如果没有 drop 能力，所有权必须在函数结束时转移，并且这些值只能在其声明模块中显式销毁。如果这些直接与相等 == 或不相等 != 一起使用，则该值将被破坏，这将破坏掉落能力的安全保证！</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct Coin has store { value: u64 }
    fun invalid(c1: Coin, c2: Coin) {
        c1 == c2 // ERROR!
//      ^^    ^^ These resources would be destroyed!
    }
}
}
</code></pre>
<p>But, a programmer can <em>always</em> borrow the value first instead of directly comparing the value, and
reference types have the <a href="./abilities.html"><code>drop</code> ability</a>. For example</p>
<p>但是，程序员总是可以先借值而不是直接比较值，并且引用类型具有删除能力。例如</p>
<pre><code class="language-move=">address 0x42 {
module example {
    struct Coin as store { value: u64 }
    fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
        let are_equal = &amp;c1 == &amp;c2; // valid
        if (are_equal) (c2, c1) else (c1, c2)
    }
}
}
</code></pre>
<h2 id="avoid-extra-copies"><a class="header" href="#avoid-extra-copies">Avoid Extra Copies</a></h2>
<p>While a programmer <em>can</em> compare any value whose type has <a href="./abilities.html"><code>drop</code></a>, a programmer
should often compare by reference to avoid expensive copies.</p>
<h2 id="避免额外的副本"><a class="header" href="#避免额外的副本">避免额外的副本</a></h2>
<p>虽然程序员可以比较任何类型下降的值，但程序员应该经常通过引用进行比较以避免昂贵的副本。</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//     ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//     ^^^^       ^^^^
use_two_foos(s1, s2);
</code></pre>
<p>This code is perfectly acceptable (assuming <code>Foo</code> has <a href="./abilities.html"><code>drop</code></a>), just not efficient.
The highlighted copies can be removed and replaced with borrows</p>
<p>这段代码是完全可以接受的（假设 Foo 已经下降），只是效率不高。突出显示的副本可以删除并替换为借用</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(&amp;v1 == &amp;v2, 42);
//     ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&amp;s1 == &amp;s2, 42);
//     ^      ^
use_two_foos(s1, s2);
</code></pre>
<p>The efficiency of the <code>==</code> itself remains the same, but the <code>copy</code>s are removed and thus the program
is more efficient.</p>
<p>== 本身的效率保持不变，但副本被删除，因此程序效率更高。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abort-and-assert"><a class="header" href="#abort-and-assert">Abort and Assert</a></h1>
<p><a href="./functions.html"><code>return</code></a> and <code>abort</code> are two control flow constructs that end execution, one for
the current function and one for the entire transaction.</p>
<p>More information on <a href="./functions.html"><code>return</code> can be found in the linked section</a></p>
<h1 id="中止和断言"><a class="header" href="#中止和断言">中止和断言</a></h1>
<p>return 和 abort 是结束执行的两种控制流结构，一种用于当前函数，一种用于整个事务。</p>
<p>有关退货的更多信息，请参见链接部分</p>
<h2 id="abort"><a class="header" href="#abort"><code>abort</code></a></h2>
<p><code>abort</code> is an expression that takes one argument: an <strong>abort code</strong> of type <code>u64</code>. For example:</p>
<h2 id="中止"><a class="header" href="#中止">中止</a></h2>
<p>abort 是一个带有一个参数的表达式：u64 类型的中止代码。例如：</p>
<pre><code class="language-move">abort 42
</code></pre>
<p>The <code>abort</code> expression halts execution the current function and reverts all changes made to global
state by the current transaction. There is no mechanism for &quot;catching&quot; or otherwise handling an
<code>abort</code>.</p>
<p>Luckily, in Move transactions are all or nothing, meaning any changes to global storage are made all
at once only if the transaction succeeds. Because of this transactional commitment of changes, after
an abort there is no need to worry about backing out changes. While this approach is lacking in
flexibility, it is incredibly simple and predictable.</p>
<p>Similar to <a href="./functions.html"><code>return</code></a>, <code>abort</code> is useful for exiting control flow when some
condition cannot be met.</p>
<p>In this example, the function will pop two items off of the vector, but will abort early if the
vector does not have two items</p>
<p>abort 表达式停止执行当前函数并恢复当前事务对全局状态所做的所有更改。没有“捕获”或以其他方式处理中止的机制。</p>
<p>幸运的是，在 Move 中，事务是全有或全无，这意味着只有在事务成功时才会对全局存储进行任何更改。由于更改的这种事务性承诺，在中止之后无需担心撤销更改。虽然这种方法缺乏灵活性，但它非常简单且可预测。</p>
<p>与 return 类似，abort 对于在某些条件无法满足时退出控制流很有用。</p>
<p>在此示例中，该函数将从向量中弹出两个项目，但如果向量没有两个项目，该函数将提前中止</p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    if (vector::length(v) &lt; 2) abort 42;

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified <code>bound</code>. And aborts otherwise</p>
<p>这在控制流结构的深处甚至更有用。例如，此函数检查向量中的所有数字是否小于指定的界限。否则中止</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        if (cur &gt; bound) abort 42;
        i = i + 1;
    }
}
</code></pre>
<h3 id="assert"><a class="header" href="#assert"><code>assert</code></a></h3>
<p><code>assert</code> is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a
condition of type <code>bool</code> and a code of type <code>u64</code></p>
<h3 id="断言"><a class="header" href="#断言">断言</a></h3>
<p>assert 是 Move 编译器提供的内置的类似宏的操作。它有两个参数，一个 bool 类型的条件和一个 u64 类型的代码</p>
<pre><code class="language-move">assert!(condition: bool, code: u64)
</code></pre>
<p>Since the operation is a macro, it must be invoked with the <code>!</code>. This is to convey that the
arguments to <code>assert</code> are call-by-expression. In other words, <code>assert</code> is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with</p>
<p>由于该操作是一个宏，因此必须使用 ! 调用它。这是为了传达断言的参数是按表达式调用的。换句话说，assert 不是一个普通的函数，在字节码级别是不存在的。它在编译器内部被替换为</p>
<pre><code class="language-move">if (condition) () else abort code
</code></pre>
<p><code>assert</code> is more commonly used than just <code>abort</code> by itself. The <code>abort</code> examples above can be
rewritten using <code>assert</code></p>
<p>assert 比 abort 本身更常用。上面的中止示例可以使用 assert 重写</p>
<pre><code class="language-move=">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    assert!(vector::length(v) &gt;= 2, 42); // Now uses 'assert'

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>and</p>
<pre><code class="language-move=">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        assert!(cur &lt;= bound, 42); // Now uses 'assert'
        i = i + 1;
    }
}
</code></pre>
<p>Note that because the operation is replaced with this <code>if-else</code>, the argument for the <code>code</code> is not
always evaluated. For example:</p>
<p>请注意，由于该操作被替换为 if-else，因此并不总是评估代码的参数。例如：</p>
<pre><code class="language-move">assert!(true, 1 / 0)
</code></pre>
<p>Will not result in an arithmetic error, it is equivalent to</p>
<p>不会导致算术错误，相当于</p>
<pre><code class="language-move">if (true) () else (1 / 0)
</code></pre>
<p>So the arithmetic expression is never evaluated!</p>
<p>所以算术表达式永远不会被评估！</p>
<h3 id="abort-codes-in-the-move-vm"><a class="header" href="#abort-codes-in-the-move-vm">Abort codes in the Move VM</a></h3>
<p>When using <code>abort</code>, it is important to understand how the <code>u64</code> code will be used by the VM.</p>
<p>Normally, after successful execution, the Move VM produces a change-set for the changes made to
global storage (added/removed resources, updates to existing resources, etc).</p>
<p>If an <code>abort</code> is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:</p>
<ul>
<li>The module that produced the abort (address and name)</li>
<li>The abort code.</li>
</ul>
<p>For example</p>
<h3 id="move-vm-中的中止代码"><a class="header" href="#move-vm-中的中止代码">Move VM 中的中止代码</a></h3>
<p>使用 abort 时，了解 VM 将如何使用 u64 代码非常重要。</p>
<p>通常，在成功执行后，Move VM 会为对全局存储所做的更改（添加/删除资源、更新现有资源等）生成一个更改集。</p>
<p>如果达到中止，VM 将改为指示错误。该错误中包含两条信息：</p>
<p>产生中止的模块（地址和名称）
中止代码。
例如</p>
<pre><code class="language-move=">address 0x2 {
module example {
    public fun aborts() {
        abort 42
    }
}
}

script {
    fun always_aborts() {
        0x2::example::aborts()
    }
}
</code></pre>
<p>If a transaction, such as the script <code>always_aborts</code> above, calls <code>0x2::example::aborts</code>, the VM
would produce an error that indicated the module <code>0x2::example</code> and the code <code>42</code>.</p>
<p>This can be useful for having multiple aborts being grouped together inside a module.</p>
<p>In this example, the module has two separate error codes used in multiple functions</p>
<p>如果事务（例如上面的脚本 always_aborts）调用 0x2::example::aborts，VM 将产生一个错误，指示模块 0x2::example 和代码 42。</p>
<p>这对于在一个模块内将多个中止组合在一起很有用。</p>
<p>在此示例中，模块有两个单独的错误代码，用于多个功能</p>
<pre><code class="language-move=">address 0x42 {
module example {

    use std::vector;

    const EMPTY_VECTOR: u64 = 0;
    const INDEX_OUT_OF_BOUNDS: u64 = 1;

    // move i to j, move j to k, move k to i
    public fun rotate_three&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64, k: u64) {
        let n = vector::length(v);
        assert!(n &gt; 0, EMPTY_VECTOR);
        assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(k &lt; n, INDEX_OUT_OF_BOUNDS);

        vector::swap(v, i, k);
        vector::swap(v, j, k);
    }

    public fun remove_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64): (T, T) {
        let n = vector::length(v);
        assert!(n &gt; 0, EMPTY_VECTOR);
        assert!(i &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(j &lt; n, INDEX_OUT_OF_BOUNDS);
        assert!(i &gt; j, INDEX_OUT_OF_BOUNDS);

        (vector::remove&lt;T&gt;(v, i), vector::remove&lt;T&gt;(v, j))
    }
}
}
</code></pre>
<h2 id="the-type-of-abort"><a class="header" href="#the-type-of-abort">The type of <code>abort</code></a></h2>
<p>The <code>abort i</code> expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.</p>
<p>The following are not useful, but they will type check</p>
<h2 id="中止类型"><a class="header" href="#中止类型">中止类型</a></h2>
<p>abort i 表达式可以有任何类型！这是因为这两种构造都脱离了正常的控制流，因此它们永远不需要评估该类型的值。</p>
<p>以下没有用，但它们会键入检查</p>
<pre><code class="language-move">let y: address = abort 0;
</code></pre>
<p>This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:</p>
<p>在您有一个分支指令在某些分支上产生值的情况下，这种行为可能会有所帮助，但不是全部。例如：</p>
<pre><code class="language-move">let b =
    if (x == 0) false
    else if (x == 1) true
    else abort 42;
//       ^^^^^^^^ `abort 42` has type `bool`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<p>An <code>if</code> expression specifies that some code should only be evaluated if a certain condition is true. For example:</p>
<h1 id="条件句"><a class="header" href="#条件句">条件句</a></h1>
<p>if 表达式指定仅当某个条件为真时才应评估某些代码。例如：</p>
<pre><code class="language-move">if (x &gt; 5) x = x - 5
</code></pre>
<p>The condition must be an expression of type <code>bool</code>.</p>
<p>An <code>if</code> expression can optionally include an <code>else</code> clause to specify another expression to evaluate when the condition is false.</p>
<p>条件必须是布尔类型的表达式。</p>
<p>if 表达式可以选择包含 else 子句，以指定另一个表达式在条件为假时进行评估。</p>
<pre><code class="language-move">if (y &lt;= 10) y = y + 1 else y = 10
</code></pre>
<p>Either the &quot;true&quot; branch or the &quot;false&quot; branch will be evaluated, but not both. Either branch can be a single expression or an expression block.</p>
<p>The conditional expressions may produce values so that the <code>if</code> expression has a result.
将评估“真”分支或“假”分支，但不会同时评估两者。任何一个分支都可以是单个表达式或表达式块。</p>
<p>条件表达式可以产生值，以便 if 表达式有结果。</p>
<pre><code class="language-move">let z = if (x &lt; 100) x else 100;
</code></pre>
<p>The expressions in the true and false branches must have compatible types. For example:</p>
<p>true 和 false 分支中的表达式必须具有兼容的类型。例如：</p>
<pre><code class="language-move=">// x and y must be u64 integers
let maximum: u64 = if (x &gt; y) x else y;

// ERROR! branches different types
let z = if (maximum &lt; 10) 10u8 else 100u64;

// ERROR! branches different types, as default false-branch is () not u64
if (maximum &gt;= 10) maximum;
</code></pre>
<p>If the <code>else</code> clause is not specified, the false branch defaults to the unit value. The following are equivalent:</p>
<p>如果没有指定 else 子句，则 false 分支默认为单位值。以下是等价的：</p>
<pre><code class="language-move">if (condition) true_branch // implied default: else ()
if (condition) true_branch else ()
</code></pre>
<p>Commonly, <a href="./conditionals.html"><code>if</code> expressions</a> are used in conjunction with expression blocks.</p>
<p>通常，if 表达式与表达式块一起使用。</p>
<pre><code class="language-move">let maximum = if (x &gt; y) x else y;
if (maximum &lt; 10) {
    x = x + 10;
    y = y + 10;
} else if (x &gt;= 10 &amp;&amp; y &gt;= 10) {
    x = x - 10;
    y = y - 10;
}
</code></pre>
<h2 id="grammar-for-conditionals"><a class="header" href="#grammar-for-conditionals">Grammar for Conditionals</a></h2>
<blockquote>
<p><em>if-expression</em> → <strong>if (</strong> <em>expression</em> <strong>)</strong> <em>expression</em> <em>else-clause</em><sub><em>opt</em></sub>
<em>else-clause</em> → <strong>else</strong> <em>expression</em></p>
</blockquote>
<h2 id="条件语法"><a class="header" href="#条件语法">条件语法</a></h2>
<p>if 表达式 → if ( 表达式 ) 表达式 else-clauseopt else-clause → else 表达式</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-and-loop"><a class="header" href="#while-and-loop">While and Loop</a></h1>
<p>Move offers two constructs for looping: <code>while</code> and <code>loop</code>.</p>
<h1 id="while-和循环"><a class="header" href="#while-和循环">While 和循环</a></h1>
<p>Move 提供了两种循环结构：while 和 loop。</p>
<h2 id="while-loops"><a class="header" href="#while-loops"><code>while</code> loops</a></h2>
<p>The <code>while</code> construct repeats the body (an expression of type unit) until the condition (an expression of type <code>bool</code>) evaluates to <code>false</code>.</p>
<p>Here is an example of simple <code>while</code> loop that computes the sum of the numbers from <code>1</code> to <code>n</code>:</p>
<h2 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h2>
<p>while 构造重复主体（单元类型的表达式），直到条件（布尔类型的表达式）评估为假。</p>
<p>下面是一个简单的 while 循环示例，它计算从 1 到 n 的数字之和：</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 1;
    while (i &lt;= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
</code></pre>
<p>Infinite loops are allowed:
允许无限循环：</p>
<pre><code class="language-move=">fun foo() {
    while (true) { }
}
</code></pre>
<h3 id="break"><a class="header" href="#break"><code>break</code></a></h3>
<p>The <code>break</code> expression can be used to exit a loop before the condition evaluates to <code>false</code>. For example, this loop uses <code>break</code> to find the smallest factor of <code>n</code> that's greater than 1:</p>
<h3 id="break-1"><a class="header" href="#break-1"><code>break</code></a></h3>
<p>break 表达式可用于在条件计算为假之前退出循环。例如，此循环使用 break 来查找 n 中大于 1 的最小因子：</p>
<pre><code class="language-move">fun smallest_factor(n: u64): u64 {
    // assuming the input is not 0 or 1
    let i = 2;
    while (i &lt;= n) {
        if (n % i == 0) break;
        i = i + 1
    };

    i
}
</code></pre>
<p>The <code>break</code> expression cannot be used outside of a loop.</p>
<p>break 表达式不能在循环外使用。</p>
<h3 id="continue"><a class="header" href="#continue"><code>continue</code></a></h3>
<p>The <code>continue</code> expression skips the rest of the loop and continues to the next iteration. This loop uses <code>continue</code> to compute the sum of <code>1, 2, ..., n</code>, except when the number is divisible by 10:</p>
<h3 id="continue-1"><a class="header" href="#continue-1"><code>continue</code></a></h3>
<p>continue 表达式跳过循环的其余部分并继续下一次迭代。此循环使用 continue 来计算 1、2、...、n 的总和，除非该数字能被 10 整除：</p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    while (i &lt; n) {
        i = i + 1;
        if (i % 10 == 0) continue;
        sum = sum + i;
    };

    sum
}
</code></pre>
<p>The <code>continue</code> expression cannot be used outside of a loop.
continue 表达式不能在循环外使用。</p>
<h3 id="the-type-of-break-and-continue"><a class="header" href="#the-type-of-break-and-continue">The type of <code>break</code> and <code>continue</code></a></h3>
<p><code>break</code> and <code>continue</code>, much like <code>return</code> and <code>abort</code>, can have any type. The following examples illustrate where this flexible typing can be helpful:</p>
<h3 id="中断和继续的类型"><a class="header" href="#中断和继续的类型">中断和继续的类型</a></h3>
<p>break 和 continue 就像 return 和 abort 一样，可以有任何类型。以下示例说明了这种灵活的类型在哪些方面会有所帮助：</p>
<pre><code class="language-move">fun pop_smallest_while_not_equal(
    v1: vector&lt;u64&gt;,
    v2: vector&lt;u64&gt;,
): vector&lt;u64&gt; {
    let result = vector::empty();
    while (!vector::is_empty(&amp;v1) &amp;&amp; !vector::is_empty(&amp;v2)) {
        let u1 = *vector::borrow(&amp;v1, vector::length(&amp;v1) - 1);
        let u2 = *vector::borrow(&amp;v2, vector::length(&amp;v2) - 1);
        let popped =
            if (u1 &lt; u2) vector::pop_back(&amp;mut v1)
            else if (u2 &lt; u1) vector::pop_back(&amp;mut v2)
            else break; // Here, `break` has type `u64`
        vector::push_back(&amp;mut result, popped);
    };

    result
}
</code></pre>
<pre><code class="language-move">fun pick(
    indexes: vector&lt;u64&gt;,
    v1: &amp;vector&lt;address&gt;,
    v2: &amp;vector&lt;address&gt;
): vector&lt;address&gt; {
    let len1 = vector::length(v1);
    let len2 = vector::length(v2);
    let result = vector::empty();
    while (!vector::is_empty(&amp;indexes)) {
        let index = vector::pop_back(&amp;mut indexes);
        let chosen_vector =
            if (index &lt; len1) v1
            else if (index &lt; len2) v2
            else continue; // Here, `continue` has type `&amp;vector&lt;address&gt;`
        vector::push_back(&amp;mut result, *vector::borrow(chosen_vector, index))
    };

    result
}
</code></pre>
<h2 id="the-loop-expression"><a class="header" href="#the-loop-expression">The <code>loop</code> expression</a></h2>
<p>The <code>loop</code> expression repeats the loop body (an expression with type <code>()</code>) until it hits a <code>break</code></p>
<p>Without a <code>break</code>, the loop will continue forever</p>
<h2 id="循环表达式"><a class="header" href="#循环表达式">循环表达式</a></h2>
<p>循环表达式重复循环体（类型为 () 的表达式），直到遇到中断</p>
<p>没有中断，循环将永远继续</p>
<pre><code class="language-move">fun foo() {
    let i = 0;
    loop { i = i + 1 }
}
</code></pre>
<p>Here is an example that uses <code>loop</code> to write the <code>sum</code> function:</p>
<p>这是一个使用循环编写求和函数的示例：</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<p>As you might expect, <code>continue</code> can also be used inside a <code>loop</code>. Here is <code>sum_intermediate</code> from above rewritten using <code>loop</code> instead of <code>while</code></p>
<p>如您所料， continue 也可以在循环内使用。这是上面使用循环而不是 while 重写的 sum_intermediate</p>
<pre><code class="language-move">fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i % 10 == 0) continue;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<h2 id="the-type-of-while-and-loop"><a class="header" href="#the-type-of-while-and-loop">The type of <code>while</code> and <code>loop</code></a></h2>
<p>Move loops are typed expressions. A <code>while</code> expression always has type <code>()</code>.</p>
<h2 id="while-和循环的类型"><a class="header" href="#while-和循环的类型">while 和循环的类型</a></h2>
<p>移动循环是类型化的表达式。 while 表达式始终具有 () 类型。</p>
<pre><code class="language-move">let () = while (i &lt; 10) { i = i + 1 };
</code></pre>
<p>If a <code>loop</code> contains a <code>break</code>, the expression has type unit <code>()</code></p>
<p>如果循环包含中断，则表达式的类型为 unit ()</p>
<pre><code class="language-move">(loop { if (i &lt; 10) i = i + 1 else break }: ());
let () = loop { if (i &lt; 10) i = i + 1 else break };
</code></pre>
<p>If <code>loop</code> does not have a <code>break</code>, <code>loop</code> can have any type much like <code>return</code>, <code>abort</code>, <code>break</code>, and <code>continue</code>.</p>
<p>如果循环包含中断，则表达式的类型为 unit ()</p>
<pre><code class="language-move">(loop (): u64);
(loop (): address);
(loop (): &amp;vector&lt;vector&lt;u8&gt;&gt;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.</p>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>Move 中的函数语法在模块函数和脚本函数之间共享。模块内部的函数是可重用的，而脚本函数仅用于调用事务一次。</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.</p>
<h2 id="声明"><a class="header" href="#声明">声明</a></h2>
<p>函数用 fun 关键字声明，后跟函数名、类型参数、形参、返回类型、获取注解，最后是函数体。</p>
<pre><code class="language-text">fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;acquires [identifier],*&gt; &lt;function_body&gt;
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.</p>
<h3 id="可见性"><a class="header" href="#可见性">可见性</a></h3>
<p>默认情况下，模块函数只能在同一个模块内调用。这些内部（有时称为私有）函数不能从其他模块或脚本调用。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>To allow access from other modules or from scripts, the function must be declared <code>public</code> or <code>public(friend)</code>.
要允许从其他模块或脚本访问，该函数必须声明为 public 或 public(friend)。</p>
<h4 id="public-visibility"><a class="header" href="#public-visibility"><code>public</code> visibility</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module or script. As shown in the following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>the function defined in a script.</li>
</ul>
<h4 id="public-可见性"><a class="header" href="#public-可见性"><code>public</code> 可见性</a></h4>
<p>公共函数可以被任何模块或脚本中定义的任何函数调用。如以下示例所示，可以通过以下方式调用公共函数：</p>
<p>在同一模块中定义的其他功能，
在另一个模块中定义的函数，或
脚本中定义的函数。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
</code></pre>
<h4 id="publicfriend-visibility"><a class="header" href="#publicfriend-visibility"><code>public(friend)</code> visibility</a></h4>
<p>The <code>public(friend)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give more control about where a function can be used. A <code>public(friend)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>functions defined in modules which are explicitly specified in the <strong>friend list</strong> (see <a href="./friends.html">Friends</a> on how to specify the friend list).</li>
</ul>
<p>Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a <code>public(friend)</code> function.</p>
<h4 id="publicfriend-可见性"><a class="header" href="#publicfriend-可见性"><code>public(friend)</code> 可见性</a></h4>
<p>public(friend) 可见性修饰符是 public 修饰符的一种更受限制的形式，可以更好地控制函数的使用位置。可以通过以下方式调用公共（朋友）函数：</p>
<p>在同一模块中定义的其他功能，或
在好友列表中明确指定的模块中定义的函数（请参阅好友了解如何指定好友列表）。
请注意，由于我们不能将脚本声明为模块的朋友，因此脚本中定义的函数永远不能调用 public(friend) 函数。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    friend 0x42::n;  // friend declaration
    public(friend) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
</code></pre>
<h3 id="entry-modifier"><a class="header" href="#entry-modifier"><code>entry</code> modifier</a></h3>
<p>The <code>entry</code> modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-<code>entry</code> function will be called from a Move program already in execution.</p>
<p>Essentially, <code>entry</code> functions are the &quot;main&quot; functions of a module, and they specify where Move programs start executing.</p>
<p>Note though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p>For example:</p>
<h3 id="entry-修饰符"><a class="header" href="#entry-修饰符"><code>entry</code> 修饰符</a></h3>
<p>entry 修饰符旨在允许像脚本一样安全直接地调用模块函数。这允许模块编写者指定哪些函数可以开始执行。然后，模块编写者知道任何非入口函数都将从已经在执行的 Move 程序中调用。</p>
<p>本质上，入口函数是模块的“主要”函数，它们指定 Move 程序开始执行的位置。</p>
<p>但请注意，其他 Move 函数仍然可以调用入口函数。因此，虽然它们可以作为 Move 程序的开始，但它们并不局限于这种情况。</p>
<p>例如：</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
</code></pre>
<p>Even internal functions can be marked as <code>entry</code>! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)
甚至内部函数也可以标记为入口！这使您可以保证仅在执行开始时调用该函数（假设您没有在模块的其他地方调用它）</p>
<pre><code class="language-move=">address 0x42 {
module m {
    entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<h3 id="name"><a class="header" href="#name">Name</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, function names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>函数名称可以以字母 a 到 z 或字母 A 到 Z 开头。在第一个字符之后，函数名称可以包含下划线 <code>_</code>、字母 a 到 z、字母 A 到 Z 或数字 0 到 9。</p>
<pre><code class="language-move">fun FOO() {}
fun bar_42() {}
fun _bAZ19() {}
</code></pre>
<h3 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h3>
<p>After the name, functions can have type parameters</p>
<h3 id="类型参数"><a class="header" href="#类型参数">类型参数</a></h3>
<p>在名称之后，函数可以有类型参数</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅移动泛型。</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>函数参数使用局部变量名声明，后跟类型注释</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<p>我们将其读为 x 具有 u64 类型</p>
<p>函数根本不需要任何参数。</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<p>这对于创建新数据结构或空数据结构的函数很常见</p>
<pre><code class="language-move=">address 0x42 {
module example {
  struct Counter { count: u64 }

  fun new_counter(): Counter {
      Counter { count: 0 }
  }

}
}
</code></pre>
<h3 id="acquires"><a class="header" href="#acquires">Acquires</a></h3>
<p>When a function accesses a resource using <code>move_from</code>, <code>borrow_global</code>, or <code>borrow_global_mut</code>, the function must indicate that it <code>acquires</code> that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.</p>
<h3 id="收购"><a class="header" href="#收购">收购</a></h3>
<p>当函数使用 move_from、borrow_global 或 borrow_global_mut 访问资源时，该函数必须表明它获取了该资源。然后 Move 的类型系统使用它来确保对全局存储的引用是安全的，特别是没有对全局存储的悬空引用。</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }
}
}
</code></pre>
<p><code>acquires</code> annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.</p>
<p>还必须为模块内的传递调用添加获取注释。从另一个模块对这些函数的调用不需要使用这些获取进行注释，因为一个模块无法访问在另一个模块中声明的资源——因此不需要注释来确保引用安全。</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }

    public fun extract_and_add(sender: address, receiver: &amp;signer) acquires Balance {
        let value = extract_balance(sender); // acquires needed here
        add_balance(receiver, value)
    }
}
}

address 0x42 {
module other {
    fun extract_balance(addr: address): u64 {
        0x42::example::extract_balance(addr) // no acquires needed
    }
}
}
</code></pre>
<p>A function can <code>acquire</code> as many resources as it needs to</p>
<p>一个函数可以根据需要获取尽可能多的资源</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector;

    struct Balance has key { value: u64 }
    struct Box&lt;T&gt; has key { items: vector&lt;T&gt; }

    public fun store_two&lt;Item1: store, Item2: store&gt;(
        addr: address,
        item1: Item1,
        item2: Item2,
    ) acquires Balance, Box {
        let balance = borrow_global_mut&lt;Balance&gt;(addr); // acquires needed
        balance.value = balance.value - 2;
        let box1 = borrow_global_mut&lt;Box&lt;Item1&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box1.items, item1);
        let box2 = borrow_global_mut&lt;Box&lt;Item2&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box2.items, item2);
    }
}
}
</code></pre>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<h3 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h3>
<p>在参数之后，函数指定其返回类型。</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using tuples, a function can return multiple values</p>
<p>这里：u64 表示函数的返回类型是u64。</p>
<p>使用元组，一个函数可以返回多个值</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These functions are equivalent</p>
<p>如果未指定返回类型，则该函数具有隐式返回类型 unit ()。这些功能是等价的</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p><code>script</code> functions must have a return type of unit <code>()</code></p>
<p>脚本函数的返回类型必须为 unit ()</p>
<pre><code class="language-move=">script {
    fun do_nothing() {
    }
}
</code></pre>
<p>As mentioned in the <a href="./tuples.html">tuples section</a>, these tuple &quot;values&quot; are virtual and do not exist at runtime. So for a function that returns unit <code>()</code>, it will not be returning any value at all during execution.</p>
<p>如元组部分所述，这些元组“值”是虚拟的，在运行时不存在。因此，对于返回 unit () 的函数，它在执行期间根本不会返回任何值。</p>
<h3 id="function-body"><a class="header" href="#function-body">Function body</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the sequence</p>
<h3 id="函数体"><a class="header" href="#函数体">函数体</a></h3>
<p>函数体是一个表达式块。函数的返回值是序列中的最后一个值</p>
<pre><code class="language-move=">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="functions.html#returning-values">the section below for more information on returns</a></p>
<p>For more information on expression blocks, see <a href="./variables.html">Move variables</a>.</p>
<p>有关退货的更多信息，请参阅以下部分</p>
<p>有关表达式块的更多信息，请参阅移动变量。</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that <code>native</code> functions are used for either standard library code or for functionality needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code such as <code>vector</code></p>
<h3 id="原生函数"><a class="header" href="#原生函数">原生函数</a></h3>
<p>有些函数没有指定主体，而是由 VM 提供的主体。这些函数被标记为原生。</p>
<p>如果不修改 VM 源代码，程序员就无法添加新的本地函数。此外，本机函数的意图是用于标准库代码或给定 Move 环境所需的功能。</p>
<p>您可能会看到的大多数本机函数都在标准库代码中，例如向量</p>
<pre><code class="language-move=">module std::vector {
    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
    ...
}
</code></pre>
<h2 id="calling"><a class="header" href="#calling">Calling</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<h2 id="调用"><a class="header" href="#调用">调用</a></h2>
<p>调用函数时，名称可以通过别名或完全限定指定</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun zero(): u64 { 0 }
}
}

script {
    use 0x42::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<p>调用函数时，必须为每个参数指定一个参数。</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<p>可以指定或推断类型参数。两个调用是等价的。</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun id&lt;T&gt;(x: T): T { x }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::id(0);
        example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅移动泛型。</p>
<h2 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<p>一个函数的结果，它的“返回值”，是它的函数体的最终值。例如</p>
<pre><code class="language-move=">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p><a href="functions.html#function-body">As mentioned above</a>, the function's body is an <a href="./variables.html">expression block</a>. The expression block can sequence various statements, and the final expression in the block will be be the value of that block</p>
<p>如上所述，函数体是一个表达式块。表达式块可以对各种语句进行排序，块中的最终表达式将是该块的值</p>
<pre><code class="language-move=">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is <code>double_x + double_y</code></p>
<p>这里的返回值为 double_x + double_y</p>
<h3 id="return-expression"><a class="header" href="#return-expression"><code>return</code> expression</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit <code>return</code> expression:</p>
<h3 id="返回表达式"><a class="header" href="#返回表达式">返回表达式</a></h3>
<p>函数隐式返回其主体计算的值。但是，函数也可以使用显式返回表达式：</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<p>这两个功能是等价的。在这个稍微复杂的示例中，该函数减去两个 u64 值，但如果第二个值太大，则提前返回 0：</p>
<pre><code class="language-move=">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:</p>
<p>请注意，这个函数的主体也可以写成 if (y x) 0 else x - y。</p>
<p>然而 return 真正闪耀的是在其他控制流结构的深处退出。在此示例中，函数遍历向量以查找给定值的索引：</p>
<pre><code class="language-move=">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two functions are equivalent:</p>
<p>使用不带参数的 return 是 return () 的简写。即以下两个函数是等价的：</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-resources"><a class="header" href="#structs-and-resources">Structs and Resources</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference type, including other structs.</p>
<p>We often refer to struct values as <em>resources</em> if they cannot be copied and cannot be dropped. In
this case, resource values must have ownership transferred by the end of the function. This property
makes resources particularly well served for defining global storage schemas or for representing
important values (such as a token).</p>
<p>By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be
dropped, and cannot be stored in global storage. This means that all values have to have ownership
transferred (linear) and the values must be dealt with by the end of the program's execution
(ephemeral). We can relax this behavior by giving the struct <a href="./abilities.html">abilities</a> which allow
values to be copied or dropped and also to be stored in global storage or to define global storage
schemas.</p>
<h1 id="结构和资源"><a class="header" href="#结构和资源">结构和资源</a></h1>
<p>结构是包含类型字段的用户定义数据结构。结构可以存储任何非引用类型，包括其他结构。</p>
<p>如果结构值无法复制且无法删除，我们通常将其称为资源。在这种情况下，资源值必须在函数结束时转移所有权。此属性使资源特别适合用于定义全局存储模式或表示重要值（例如令牌）。</p>
<p>默认情况下，结构是线性的和短暂的。我们的意思是它们：不能被复制，不能被删除，不能被存储在全局存储中。这意味着所有值都必须转移所有权（线性），并且必须在程序执行结束时处理这些值（临时）。我们可以通过赋予 struct 允许复制或删除值以及存储在全局存储中或定义全局存储模式的能力来放松这种行为。</p>
<h2 id="defining-structs"><a class="header" href="#defining-structs">Defining Structs</a></h2>
<p>Structs must be defined inside a module:</p>
<h2 id="定义结构"><a class="header" href="#定义结构">定义结构</a></h2>
<p>结构必须在模块内定义：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar {}
    struct Baz { foo: Foo, }
    //                   ^ note: it is fine to have a trailing comma
}
}
</code></pre>
<p>Structs cannot be recursive, so the following definition is invalid:
结构不能递归，所以下面的定义是无效的：</p>
<pre><code class="language-move=">struct Foo { x: Foo }
//              ^ error! Foo cannot contain Foo
</code></pre>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used with certain operations (that copy it, drop it, store it in global storage, or use it as
a storage schema), structs can be granted <a href="./abilities.html">abilities</a> by annotating them with
<code>has &lt;ability&gt;</code>:</p>
<p>如上所述：默认情况下，结构声明是线性且短暂的。因此，为了允许将值用于某些操作（复制、删除、将其存储在全局存储中或将其用作存储模式），可以通过使用 has ability 注释它们来授予结构能力：</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64, y: bool }
}
}
</code></pre>
<p>For more details, see the <a href="./abilities.html#annotating-structs">annotating structs</a> section.
有关更多详细信息，请参阅注释结构部分。</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<h3 id="命名"><a class="header" href="#命名">命名</a></h3>
<p>结构必须以大写字母 A 到 Z 开头。在第一个字母之后，常量名称可以包含下划线 <code>_</code>、字母 a 到 z、字母 A 到 Z 或数字 0 到 9。</p>
<pre><code class="language-move">struct Foo {}
struct BAR {}
struct B_a_z_4_2 {}
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<p>这种以 A 到 Z 开头的命名限制是为了给未来的语言特性留出空间。以后可能会或可能不会删除它。</p>
<h2 id="using-structs"><a class="header" href="#using-structs">Using Structs</a></h2>
<h3 id="creating-structs"><a class="header" href="#creating-structs">Creating Structs</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field:</p>
<h2 id="使用结构"><a class="header" href="#使用结构">使用结构</a></h2>
<h3 id="创建结构"><a class="header" href="#创建结构">创建结构</a></h3>
<p>可以通过指示结构名称来创建（或“打包”）结构类型的值，然后是每个字段的值：</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo has drop { x: u64, y: bool }
    struct Baz has drop { foo: Foo }

    fun example() {
        let foo = Foo { x: 0, y: false };
        let baz = Baz { foo: foo };
    }
}
}
</code></pre>
<p>If you initialize a struct field with a local variable whose name is the same as the field, you can
use the following shorthand:</p>
<p>如果使用与字段名称相同的局部变量初始化结构字段，则可以使用以下简写：</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
</code></pre>
<p>This is called sometimes called &quot;field name punning&quot;.</p>
<p>这有时称为“字段名称双关语”。</p>
<h3 id="destroying-structs-via-pattern-matching"><a class="header" href="#destroying-structs-via-pattern-matching">Destroying Structs via Pattern Matching</a></h3>
<p>Struct values can be destroyed by binding or assigning them patterns.</p>
<h3 id="通过模式匹配销毁结构"><a class="header" href="#通过模式匹配销毁结构">通过模式匹配销毁结构</a></h3>
<p>结构值可以通过绑定或分配模式来销毁。</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar { foo: Foo }
    struct Baz {}

    fun example_destroy_foo() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: foo_y } = foo;
        //        ^ shorthand for `x: x`

        // two new bindings
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_foo_wildcard() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: _ } = foo;
        // only one new binding since y was bound to a wildcard
        //   x: u64 = 3
    }

    fun example_destroy_foo_assignment() {
        let x: u64;
        let y: bool;
        Foo { x, y } = Foo { x: 3, y: false };
        // mutating existing variables x &amp; y
        //   x = 3, y = false
    }

    fun example_foo_ref() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;foo;
        // two new bindings
        //   x: &amp;u64
        //   y: &amp;bool
    }

    fun example_foo_ref_mut() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;mut foo;
        // two new bindings
        //   x: &amp;mut u64
        //   y: &amp;mut bool
    }

    fun example_destroy_bar() {
        let bar = Bar { foo: Foo { x: 3, y: false } };
        let Bar { foo: Foo { x, y } } = bar;
        //             ^ nested pattern
        // two new bindings
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_baz() {
        let baz = Baz {};
        let Baz {} = baz;
    }
}
}
</code></pre>
<h3 id="borrowing-structs-and-fields"><a class="header" href="#borrowing-structs-and-fields">Borrowing Structs and Fields</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<h3 id="借用结构和字段"><a class="header" href="#借用结构和字段">借用结构和字段</a></h3>
<p>&amp; 和 &amp;mut 运算符可用于创建对结构或字段的引用。这些示例包括一些可选的类型注释（例如：&amp;Foo）来演示操作的类型。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;          // reading a field via a reference to the struct
let x_ref: &amp;u64 = &amp;foo.x;

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // modifying a field via a mutable reference
</code></pre>
<p>It is possible to borrow inner fields of nested structs.</p>
<p>可以借用嵌套结构的内部字段。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };

let x_ref = &amp;bar.foo.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct.</p>
<p>您还可以通过对结构的引用来借用字段。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// this has the same effect as let x_ref = &amp;foo.x
</code></pre>
<h3 id="reading-and-writing-fields"><a class="header" href="#reading-and-writing-fields">Reading and Writing Fields</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field</p>
<h3 id="阅读和写作领域"><a class="header" href="#阅读和写作领域">阅读和写作领域</a></h3>
<p>如果您需要读取和复制字段的值，则可以取消引用借用的字段</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo: copy foo };
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.foo;
</code></pre>
<p>If the field is implicitly copyable, the dot operator can be used to read fields of a struct without
any borrowing. (Only scalar values with the <code>copy</code> ability are implicitly copyable.)</p>
<p>如果该字段是隐式可复制的，则点运算符可用于读取结构的字段而无需任何借用。 （只有具有复制能力的标量值是隐式可复制的。）</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields.</p>
<p>点运算符可以链接起来访问嵌套字段。</p>
<pre><code class="language-move=">let baz = Baz { foo: Foo { x: 3, y: true } };
let x = baz.foo.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct</p>
<p>但是，对于包含非原始类型（例如向量或其他结构）的字段，这是不允许的</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };
let foo2: Foo = *&amp;bar.foo;
let foo3: Foo = bar.foo; // error! add an explicit copy with *&amp;
</code></pre>
<p>The reason behind this design decision is that copying a vector or another struct might be an
expensive operation. It is important for a programmer to be aware of this copy and make others aware
with the explicit syntax <code>*&amp;</code></p>
<p>In addition reading from fields, the dot syntax can be used to modify fields, regardless of the
field being a primitive type or some other struct</p>
<p>这个设计决策背后的原因是复制一个向量或另一个结构可能是一项昂贵的操作。对于程序员来说，了解这个副本并使用显式语法 <code>*&amp;</code> 让其他人了解是很重要的</p>
<p>除了从字段中读取之外，点语法还可用于修改字段，无论该字段是原始类型还是其他结构</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }
bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }
bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }
</code></pre>
<p>The dot syntax also works via a reference to a struct</p>
<p>点语法也可以通过对结构的引用来工作</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="privileged-struct-operations"><a class="header" href="#privileged-struct-operations">Privileged Struct Operations</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide publis APIs for them. The end of the chapter contains some examples of this.</p>
<p>However, struct <em>types</em> are always visible to another module or script:</p>
<h2 id="特权结构操作"><a class="header" href="#特权结构操作">特权结构操作</a></h2>
<p>大多数对结构类型 T 的结构操作只能在声明 T 的模块内执行：</p>
<ul>
<li>结构类型只能在定义结构的模块内创建（“打包”）、销毁（“解包”）。</li>
<li>结构的字段只能在定义结构的模块内部访问。
遵循这些规则，如果你想在模块之外修改你的结构，你需要为它们提供 publis API。本章的最后包含了这方面的一些例子。</li>
</ul>
<p>但是，结构类型始终对另一个模块或脚本可见：</p>
<pre><code class="language-move=">// m.move
address 0x2 {
module m {
    struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}
}
</code></pre>
<pre><code class="language-move=">// n.move
address 0x2 {
module n {
    use 0x2::m;

    struct Wrapper has drop {
        foo: m::Foo
    }

    fun f1(foo: m::Foo) {
        let x = foo.x;
        //      ^ error! cannot access fields of `foo` here
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
    }
}
}
</code></pre>
<p>Note that structs do not have visibility modifiers (e.g., <code>public</code> or <code>private</code>).</p>
<p>请注意，结构没有可见性修饰符（例如，公共或私有）。</p>
<h2 id="ownership-4"><a class="header" href="#ownership-4">Ownership</a></h2>
<p>As mentioned above in <a href="structs-and-resources.html#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world resources like money, as you do not want money to be duplicated or get lost in
circulation.</p>
<h2 id="所有权-7"><a class="header" href="#所有权-7">所有权</a></h2>
<p>正如上面定义结构中提到的，结构默认是线性的和短暂的。这意味着它们不能被复制或删除。在模拟货币等现实世界资源时，此属性非常有用，因为您不希望货币被复制或在流通中丢失。</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun copying_resource() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability
        let foo_ref = &amp;foo;
        let another_copy = *foo_ref // error! dereference requires the 'copy' ability
    }

    public fun destroying_resource1() {
        let foo = Foo { x: 100 };

        // error! when the function returns, foo still contains a value.
        // This destruction requires the 'drop' ability
    }

    public fun destroying_resource2(f: &amp;mut Foo) {
        *f = Foo { x: 100 } // error!
                            // destroying the old value via a write requires the 'drop' ability
    }
}
}
</code></pre>
<p>To fix the second example (<code>fun dropping_resource</code>), you would need to manually &quot;unpack&quot; the
resource:</p>
<p>要修复第二个示例（有趣的 drop_resource），您需要手动“解包”资源：</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo { x: u64 }

    public fun destroying_resource1_fixed() {
        let foo = Foo { x: 100 };
        let Foo { x: _ } = foo;
    }
}
}
</code></pre>
<p>Recall that you are only able to deconstruct a resource within the module in which it is defined.
This can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<p>回想一下，您只能在定义资源的模块中解构资源。这可以用来在系统中强制执行某些不变量，例如货币守恒。</p>
<p>另一方面，如果您的结构不代表有价值的东西，您可以添加功能复制和删除以获取可能对其他编程语言更熟悉的结构值：</p>
<pre><code class="language-move=">address 0x2 {
module m {
    struct Foo has copy, drop { x: u64 }

    public fun run() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo;
        // ^ this code copies foo, whereas `let x = foo` or
        // `let x = move foo` both move foo

        let x = foo.x;            // x = 100
        let x_copy = foo_copy.x;  // x = 100

        // both foo and foo_copy are implicitly discarded when the function returns
    }
}
}
</code></pre>
<h2 id="storing-resources-in-global-storage"><a class="header" href="#storing-resources-in-global-storage">Storing Resources in Global Storage</a></h2>
<p>Only structs with the <code>key</code> ability can be saved directly in
<a href="./global-storage-operators.html">persistent global storage</a>. All values stored within those <code>key</code>
structs must have the <code>store</code> abilities. See the <a href="./abilities">ability</a> and
<a href="./global-storage-operators.html">global storage</a> chapters for more detail.</p>
<h2 id="在全局存储中存储资源"><a class="header" href="#在全局存储中存储资源">在全局存储中存储资源</a></h2>
<p>只有具有关键能力的结构才能直接保存在持久性全局存储中。存储在这些键结构中的所有值都必须具有存储能力。有关更多详细信息，请参阅能力和全局存储章节。</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>Here are two short examples of how you might use structs to represent valuable data (in the case of
<code>Coin</code>) or more classical data (in the case of <code>Point</code> and <code>Circle</code>)</p>
<h2 id="例子-3"><a class="header" href="#例子-3">例子</a></h2>
<p>这里有两个简短的示例，说明如何使用结构来表示有价值的数据（在 Coin 的情况下）或更经典的数据（在 Point 和 Circle 的情况下）</p>
<h3 id="example-1-coin"><a class="header" href="#example-1-coin">Example 1: Coin</a></h3>
<h3 id="示例-1硬币"><a class="header" href="#示例-1硬币">示例 1：硬币</a></h3>
<!-- TODO link to access control for mint -->
<pre><code class="language-move=">address 0x2 {
module m {
    // We do not want the Coin to be copied because that would be duplicating this &quot;money&quot;,
    // so we do not give the struct the 'copy' ability.
    // Similarly, we do not want programmers to destroy coins, so we do not give the struct the
    // 'drop' ability.
    // However, we *want* users of the modules to be able to store this coin in persistent global
    // storage, so we grant the struct the 'store' ability. This struct will only be inside of
    // other resources inside of global storage, so we do not give the struct the 'key' ability.
    struct Coin has store {
        value: u64,
    }

    public fun mint(value: u64): Coin {
        // You would want to gate this function with some form of access control to prevent
        // anyone using this module from minting an infinite amount of coins
        Coin { value }
    }

    public fun withdraw(coin: &amp;mut Coin, amount: u64): Coin {
        assert!(coin.balance &gt;= amount, 1000);
        coin.value = coin.value - amount;
        Coin { value: amount }
    }

    public fun deposit(coin: &amp;mut Coin, other: Coin) {
        let Coin { value } = other;
        coin.value = coin.value + value;
    }

    public fun split(coin: Coin, amount: u64): (Coin, Coin) {
        let other = withdraw(&amp;mut coin, amount);
        (coin, other)
    }

    public fun merge(coin1: Coin, coin2: Coin): Coin {
        deposit(&amp;mut coin1, coin2);
        coin1
    }

    public fun destroy_zero(coin: Coin) {
        let Coin { value } = coin;
        assert!(value == 0, 1001);
    }
}
}
</code></pre>
<h3 id="example-2-geometry"><a class="header" href="#example-2-geometry">Example 2: Geometry</a></h3>
<h3 id="示例-2几何"><a class="header" href="#示例-2几何">示例 2：几何</a></h3>
<pre><code class="language-move=">address 0x2 {
module point {
    struct Point has copy, drop, store {
        x: u64,
        y: u64,
    }

    public fun new(x: u64, y: u64): Point {
        Point {
            x, y
        }
    }

    public fun x(p: &amp;Point): u64 {
        p.x
    }

    public fun y(p: &amp;Point): u64 {
        p.y
    }

    fun abs_sub(a: u64, b: u64): u64 {
        if (a &lt; b) {
            b - a
        }
        else {
            a - b
        }
    }

    public fun dist_squared(p1: &amp;Point, p2: &amp;Point): u64 {
        let dx = abs_sub(p1.x, p2.x);
        let dy = abs_sub(p1.y, p2.y);
        dx*dx + dy*dy
    }
}
}
</code></pre>
<pre><code class="language-move=">address 0x2 {
module circle {
    use 0x2::Point::{Self, Point};

    struct Circle has copy, drop, store {
        center: Point,
        radius: u64,
    }

    public fun new(center: Point, radius: u64): Circle {
        Circle { center, radius }
    }

    public fun overlaps(c1: &amp;Circle, c2: &amp;Circle): bool {
        let d = Point::dist_squared(&amp;c1.center, &amp;c2.center);
        let r1 = c1.radius;
        let r2 = c2.radius;
        d*d &lt;= r1*r1 + 2*r1*r2 + r2*r2
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constants are a way of giving a name to shared, static values inside of a <code>module</code> or <code>script</code>.</p>
<p>The constant's must be known at compilation. The constant's value is stored in the compiled module
or script. And each time the constant is used, a new copy of that value is made.</p>
<h1 id="常数"><a class="header" href="#常数">常数</a></h1>
<p>常量是为模块或脚本内的共享静态值命名的一种方式。</p>
<p>常量必须在编译时知道。常量的值存储在编译的模块或脚本中。每次使用该常量时，都会生成该值的新副本。</p>
<h2 id="declaration-1"><a class="header" href="#declaration-1">Declaration</a></h2>
<p>Constant declarations begin with the <code>const</code> keyword, followed by a name, a type, and a value. They
can exist in either a script or module</p>
<h2 id="声明-1"><a class="header" href="#声明-1">声明</a></h2>
<p>常量声明以 const 关键字开头，后跟名称、类型和值。它们可以存在于脚本或模块中</p>
<pre><code class="language-text">const &lt;name&gt;: &lt;type&gt; = &lt;expression&gt;;
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move=">script {

    const MY_ERROR_CODE: u64 = 0;

    fun main(input: u64) {
        assert!(input &gt; 0, MY_ERROR_CODE);
    }

}

address 0x42 {
module example {

    const MY_ADDRESS: address = @0x42;

    public fun permissioned(s: &amp;signer) {
        assert!(std::signer::address_of(s) == MY_ADDRESS, 0);
    }

}
}
</code></pre>
<h2 id="naming-1"><a class="header" href="#naming-1">Naming</a></h2>
<p>Constants must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<h2 id="命名-1"><a class="header" href="#命名-1">命名</a></h2>
<p>常量必须以大写字母 A 到 Z 开头。在第一个字母之后，常量名称可以包含下划线 <code>_</code>、字母 a 到 z、字母 A 到 Z 或数字 0 到 9。</p>
<pre><code class="language-move">const FLAG: bool = false;
const MY_ERROR_CODE: u64 = 0;
const ADDRESS_42: address = @0x42;
</code></pre>
<p>Even though you can use letters <code>a</code> to <code>z</code> in a constant. The
<a href="./coding-conventions.html">general style guidelines</a> are to use just uppercase letters <code>A</code> to <code>Z</code>,
with underscores <code>_</code> between each word.</p>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<p>即使您可以在常数中使用字母 a 到 z。一般的风格准则是只使用大写字母 A 到 Z，每个单词之间用下划线 <code>_</code>。</p>
<p>这种以 A 到 Z 开头的命名限制是为了给未来的语言特性留出空间。以后可能会或可能不会删除它。</p>
<h2 id="visibility-1"><a class="header" href="#visibility-1">Visibility</a></h2>
<p><code>public</code> constants are not currently supported. <code>const</code> values can be used only in the declaring
module.</p>
<h2 id="可见性-1"><a class="header" href="#可见性-1">可见性</a></h2>
<p>当前不支持公共常量。 const 值只能在声明模块中使用。</p>
<h2 id="valid-expressions"><a class="header" href="#valid-expressions">Valid Expressions</a></h2>
<p>Currently, constants are limited to the primitive types <code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, <code>address</code>, and
<code>vector&lt;u8&gt;</code>. Future support for other <code>vector</code> values (besides the &quot;string&quot;-style literals) will
come later.</p>
<h2 id="有效表达式"><a class="header" href="#有效表达式">有效表达式</a></h2>
<p>目前，常量仅限于基本类型 bool、u8、u64、u128、address 和向量 u8。未来对其他向量值的支持（除了“字符串”样式的文字）将在稍后提供。</p>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<p>Commonly, <code>const</code>s are assigned a simple value, or literal, of their type. For example</p>
<h3 id="值"><a class="header" href="#值">值</a></h3>
<p>通常，为 const 分配其类型的简单值或文字。例如</p>
<pre><code class="language-move">const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector&lt;u8&gt; = b&quot;hello world&quot;;
const HEX_BYTES: vector&lt;u8&gt; = x&quot;DEADBEEF&quot;;
</code></pre>
<h3 id="complex-expressions"><a class="header" href="#complex-expressions">Complex Expressions</a></h3>
<p>In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.</p>
<p>Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.</p>
<h3 id="复杂表达式"><a class="header" href="#复杂表达式">复杂表达式</a></h3>
<p>除了文字之外，常量还可以包含更复杂的表达式，只要编译器能够在编译时将表达式简化为一个值即可。</p>
<p>目前，可以使用相等运算、所有布尔运算、所有位运算和所有算术运算。</p>
<pre><code class="language-move">const RULE: bool = true &amp;&amp; false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
  (1 &lt;&lt; 1) * (1 &lt;&lt; 2) * (1 &lt;&lt; 3) * (1 &lt;&lt; 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const EQUAL: bool = 1 == 1;
</code></pre>
<p>If the operation would result in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value</p>
<p>如果操作会导致运行时异常，编译器将给出无法生成常量值的错误</p>
<pre><code class="language-move">const DIV_BY_ZERO: u64 = 1 / 0; // error!
const SHIFT_BY_A_LOT: u64 = 1 &lt;&lt; 100; // error!
const NEGATIVE_U64: u64 = 0 - 1; // error!
</code></pre>
<p>Note that constants cannot currently refer to other constants. This feature, along with support for
other expressions, will be added in the future.
请注意，常量当前不能引用其他常量。将来会添加此功能以及对其他表达式的支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>泛型可用于定义具有不同输入数据类型的函数和结构体。这种语言特性有时被称为<em>参数多态</em>（parametric polymorphism）。在 Move 中，我们经常将术语泛型与类型形参（type parameter）和类型实参（type argument）互换使用。<em>（有些书籍的中文翻译通常将 type parameter 和 type argument 不加以区别地翻译为“类型参数”，译者注）</em></p>
<p>泛型通常用于库（library）代码中，例如向量中，声明适用于任何可能的实例化（满足指定约束）的代码。在其他框架中，泛型代码有时可用多种不同的方式与全局存储进行交互，这些方式有着相同的实现。</p>
<h2 id="声明类型参数"><a class="header" href="#声明类型参数">声明类型参数</a></h2>
<p>函数和结构体都可以在其签名中带上类型参数列表，由一对尖括号括起来 <code>&lt;...&gt;</code>。</p>
<h3 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h3>
<p>函数的类型参数放在函数名称之后和（值）参数列表之前。以下代码定义了一个泛型标识函数，该函数接受任何类型的值并返回原值。</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // 此类型标注是不必要但有效的
    (x: T)
}
</code></pre>
<p>一旦定义，类型参数 <code>T</code> 就可以在参数类型、返回类型和函数体内使用。</p>
<h3 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h3>
<p>结构体的类型参数放在结构名称之后，可用于命名字段的类型。</p>
<pre><code class="language-move">struct Foo&lt;T&gt; has copy, drop { x: T }

struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p>请注意，<a href="generics.html#%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">未使用的类型参数</a>。</p>
<h2 id="类型实参"><a class="header" href="#类型实参">类型实参</a></h2>
<h3 id="调用泛型函数"><a class="header" href="#调用泛型函数">调用泛型函数</a></h3>
<p>调用泛型函数时，可以在由一对尖括号括起来的列表中为函数的类型形参指定类型实参。</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>如果你不指定类型实参，Move 的<a href="generics.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a>（功能）将为你提供它们。</p>
<h3 id="使用泛型结构体"><a class="header" href="#使用泛型结构体">使用泛型结构体</a></h3>
<p>类似地，在构造或销毁泛型类型的值时，可以为结构体的类型参数附加一个类型实参列表。</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: true };
    let Foo&lt;bool&gt; { x } = foo;
}
</code></pre>
<p>如果你不指定类型实参，Move 的<a href="generics.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a>（功能）将为你提供它们。</p>
<h3 id="类型实参不匹配"><a class="header" href="#类型实参不匹配">类型实参不匹配</a></h3>
<p>如果你指定类型实参并且它们与提供的实际值冲突，则会报错：</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // 错误！true 不是 u64
}
</code></pre>
<p>同样地：</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // 错误！0 不是布尔值
    let Foo&lt;address&gt; { x } = foo; // 错误！bool 与 address 不兼容
}
</code></pre>
<h2 id="类型推断"><a class="header" href="#类型推断">类型推断</a></h2>
<p>在大多数情况下，Move 编译器能够推断类型实参，因此你不必显式地写下它们。如果我们省略类型实参，上面的例子会是这样的：</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ 被推断为 &lt;bool&gt;

    let foo = Foo { x: true };
    //           ^ 被推断为 &lt;bool&gt;

    let Foo { x } = foo;
    //     ^ 被推断为 &lt;bool&gt;
}
</code></pre>
<p>注意：当编译器无法推断类型时，你需要手动标注它们。一个常见的场景是调用一个函数，其类型参数只出现在返回位置。</p>
<pre><code class="language-move">address 0x2 {
module m {
    using std::vector;

    fun foo() {
        // let v = vector::new();
        //                    ^ 编译器无法确定元素类型。

        let v = vector::new&lt;u64&gt;();
        //                 ^~~~~ 必须手动标注。
    }
}
}
</code></pre>
<p>但是，如果稍后在该函数中使用该返回值，编译器将能够推断其类型：</p>
<pre><code class="language-move">address 0x2 {
module m {
    using std::vector;

    fun foo() {
        let v = vector::new();
        //                 ^ 被推断为 &lt;u64&gt;
        vector::push_back(&amp;mut v, 42);
    }
}
}
</code></pre>
<h2 id="未使用的类型参数"><a class="header" href="#未使用的类型参数">未使用的类型参数</a></h2>
<p>对于结构体定义，未使用的类型参数是没有出现在结构体定义的任何字段中，但在编译时静态检查的类型参数。Move 允许未使用的类型参数，因此以下结构体定义有效：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>这在对某些概念建模时会很方便。这是一个例子：</p>
<pre><code class="language-move">address 0x2 {
module m {
    // 货币说明符
    struct Currency1 {}
    struct Currency2 {}

    // 可以使用货币说明符类型实例化的泛型钱币类型。
    // 例如 Coin&lt;Currency1&gt;, Coin&lt;Currency2&gt; 等。
    struct Coin&lt;Currency&gt; has store {
        value: u64
    }

    // 泛型地编写有关所有货币的代码
    public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
        Coin { value }
    }

    // 具体编写关于一种货币的代码
    public fun mint_concrete(value: u64): Coin&lt;Currency1&gt; {
        Coin { value }
    }
}
}
</code></pre>
<p>在此示例中，<code>struct Coin&lt;Currency&gt;</code> 是类型参数为 <code>Currency</code> 的泛型结构体，该参数指定钱币的货币（类型），并允许将代码泛型地写入任何货币或具体地写入特定货币。即使 <code>Currency</code> 类型参数未出现在 <code>Coin</code> 中定义的任何字段中，这种通用性也适用。</p>
<h3 id="虚类型参数"><a class="header" href="#虚类型参数">虚类型参数</a></h3>
<p>在上面的例子中，虽然 <code>struct Coin</code> 要求有 <code>store</code> 能力，但 <code>Coin&lt;Currency1&gt;</code> 和 <code>Coin&lt;Currency2&gt;</code> 都没有 <code>store</code> 能力。这实际是因为<a href="./abilities.html#%E6%9D%A1%E4%BB%B6%E8%83%BD%E5%8A%9B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B">条件能力与泛型类型</a>的规则以及 <code>Currency1</code> 和 <code>Currency2</code> 没有 <code>store</code> 能力，尽管它们甚至没有在 <code>struct Coin</code> 的结构体中使用。这可能会导致一些不合意的后果。例如，我们无法将 <code>Coin&lt;Currency1&gt;</code> 放入全局存储中的钱包。</p>
<p>一种可能的解决方案是向 <code>Currency1</code> 和 <code>Currency2</code> 添加伪能力（spurious ability）标注（例如：<code>struct Currency1 has store {}</code>）。但是，这可能会导致错误（bug）或安全漏洞，因为它削弱了类型，引入了不必要的能力声明。例如，我们永远不会期望全局存储中的资源有一个类型为 <code>Currency1</code> 的字段，但是通过伪 <code>store</code> 能力这是有可能的。此外，伪标注具有传染性，需要在许多未使用类型参数的泛型函数上也包含必要的约束。</p>
<p>虚类型（phantom type）参数解决了这个问题。未使用的类型参数可以标记为 <em>phantom</em> 类型参数，不参与结构体的能力推导。这样，在派生泛型类型的能力时，不考虑虚类型参数的实参，从而避免了对伪能力标注的需要。为了使这个宽松的规则合理，Move 的类型系统保证声明为 <code>phantom</code> 的参数要么在结构体定义根本不使用，要么仅用作声明为 <code>phantom</code> 的类型参数的实参。</p>
<h4 id="声明-2"><a class="header" href="#声明-2">声明</a></h4>
<p>在结构定义中，可以通过在声明前添加 <code>phantom</code> 关键字来将类型参数声明为 phantom。如果一个类型参数被声明为 phantom，我们就说它是一个虚类型参数。在定义结构时，Move 的类型检查器确保每个虚类型参数要么未在结构定义中使用，要么仅用作虚类型参数的实参。</p>
<p>更正式地说，如果一个类型被用作虚类型参数的实参，我们说该类型出现在_虚位置_。有了这个定义，正确使用虚参数的规则可以指定如下：<strong>虚类型参数只能出现在虚位置</strong>。</p>
<p>以下两个示例显示了虚参数的合法使用。在第一个中，结构定义中根本没有使用参数 <code>T1</code>。在第二个中，参数 <code>T1</code> 仅用作虚类型参数的实参。</p>
<pre><code class="language-move">struct S1&lt;phantom T1, T2&gt; { f: u64 }
                  ^^
                  Ok: T1 没有出现在结构定义中

struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
                                  ^^
                                  Ok: T1 出现在虚位置
</code></pre>
<p>以下代码展示违反规则的示例：</p>
<pre><code class="language-move">struct S1&lt;phantom T&gt; { f: T }
                          ^
                          错误：不是虚位置

struct S2&lt;T&gt; { f: T }

struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
                             ^
                             错误：不是虚位置
</code></pre>
<h4 id="实例化"><a class="header" href="#实例化">实例化</a></h4>
<p>实例化结构时，在派生结构能力时排除虚参数的实参。例如，考虑以下代码：</p>
<pre><code class="language-move">struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
struct NoCopy {}
struct HasCopy has copy {}
</code></pre>
<p>现在考虑类型 <code>S&lt;HasCopy, NoCopy&gt;</code>。因为 <code>S</code> 是用 <code>copy</code> 定义的，并且所有非虚参数都有 copy 能力，所以 <code>S&lt;HasCopy, NoCopy&gt;</code> 也有 copy 能力。</p>
<h4 id="具有能力约束的虚类型参数"><a class="header" href="#具有能力约束的虚类型参数">具有能力约束的虚类型参数</a></h4>
<p>能力约束和虚类型参数是正交特征，虚参数可以用能力约束来声明。当实例化具有能力约束的虚类型参数时，类型实参必须满足该约束，即使该参数是虚的（phantom）。例如，以下定义是完全有效的：</p>
<pre><code class="language-move">struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>通常用来限制应用并且 <code>T</code> 只能用具有 <code>copy</code> 的实参实例化。</p>
<h2 id="约束"><a class="header" href="#约束">约束</a></h2>
<p>在上面的示例中，我们演示了如何使用类型参数来定义稍后可以由调用者插入的“未知”类型。然而，这意味着类型系统几乎没有关于类型的信息，并且必须以非常保守的方式执行检查。在某种意义上，类型系统必须为不受约束的泛型假设最坏的情况。简单地说，默认泛型类型参数没有<a href="./abilities.html">能力</a>。</p>
<p>这就是约束发挥作用的地方：它们提供了一种方法来指定这些未知类型具有哪些属性，以便类型系统可以允许在其他情况下不安全的操作。</p>
<h3 id="声明约束"><a class="header" href="#声明约束">声明约束</a></h3>
<p>可以使用以下语法对类型参数施加约束。</p>
<pre><code class="language-move">// T 是类型参数的名称
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p><code>&lt;ability&gt;</code> 可以是四种<a href="./abilities.html">能力</a>中的任何一种，一个类型参数可以同时被多种能力约束。因此，以下所有内容都是有效的类型参数声明：</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="验证约束"><a class="header" href="#验证约束">验证约束</a></h3>
<p>在调用点检查约束，所以下面的代码不会编译。</p>
<pre><code class="language-move">struct Foo&lt;T: key&gt; { x: T }

struct Bar { x: Foo&lt;u8&gt; }
//                  ^ 错误！u8 没有 'key'

struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                     ^ 错误！ t 没有 'key'
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_consume&lt;T&gt;(x: T) {
    // 错误！x 没有 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // 合法！
    // x 会被自动删除
}

fun foo() {
    let r = R {};
    consume&lt;R&gt;(r);
    //      ^ 错误！r 没有 'drop'
}
</code></pre>
<pre><code class="language-move">struct R {}

fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // 错误！x 没有 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // 合法！
}

fun foo(): (R, R) {
    let r = R {};
    double&lt;R&gt;(r)
    //     ^ 错误！R 没有 'error'
}
</code></pre>
<p>有关详细信息，请参阅有关<a href="./abilities.html#conditional-abilities-and-generic-types">条件能力与泛型类型</a>。</p>
<h2 id="递归的限制"><a class="header" href="#递归的限制">递归的限制</a></h2>
<h3 id="递归结构体"><a class="header" href="#递归结构体">递归结构体</a></h3>
<p>泛型结构不能直接或间接包含相同类型的字段，即使具有不同类型的参数也是如此。以下所有结构定义均无效：</p>
<pre><code class="language-move">struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // 错误！'Foo' 包含 'Foo'
}

struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // 错误！'Bar' 包含 'Bar'
}

// 错误！'A' 和 'B' 形成一个循环，这也是不允许的。
struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="高级主题类型级递归"><a class="header" href="#高级主题类型级递归">高级主题：类型级递归</a></h3>
<p>Move 允许递归调用泛型函数。然而，当与泛型结构体结合使用时，在某些情况下这可能会创建无限数量的类型，这意味着会给编译器、虚拟机（mv）和其他语言组件增加不必要的复杂性。因此，这样的递归是被禁止的。</p>
<p>被允许的用法：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    // 有限多种类型 —— 允许。
    // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;T&gt;();
    }

    // 有限多种类型 —— 允许。
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;A&lt;u64&gt;&gt;();
    }
}
}
</code></pre>
<p>不被允许的用法：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    // 无限多种类型 —— 不允许。
    // 错误！
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
    fun foo&lt;T&gt;() {
        foo&lt;Foo&lt;T&gt;&gt;();
    }
}
}
</code></pre>
<pre><code class="language-move">address 0x2 {
module n {
    struct A&lt;T&gt; {}

    // 无限多种类型 —— 不允许。
    // 错误！
    // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
    //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
    //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
    //   -&gt; ...
    fun foo&lt;T1, T2&gt;() {
        bar&lt;T2, T1&gt;();
    }

    fun bar&lt;T1, T2&gt; {
        foo&lt;T1, A&lt;T2&gt;&gt;();
    }
}
}
</code></pre>
<p>请注意，类型级递归的检查基于对调用点的保守分析，所以不考虑控制流或运行时值。</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct A&lt;T&gt; {}

    fun foo&lt;T&gt;(n: u64) {
        if (n &gt; 0) {
            foo&lt;A&lt;T&gt;&gt;(n - 1);
        };
    }
}
}
</code></pre>
<p>上面示例中的函数在技术上将终止任何给定的输入，因此只会创建有限多种类型，但它仍然被 Move 的类型系统视为无效的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities"><a class="header" href="#abilities">Abilities</a></h1>
<p>Abilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine grained control over the &quot;linear&quot; typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all—not every instruction is gated by an ability).</p>
<h1 id="能力"><a class="header" href="#能力">能力</a></h1>
<p>能力是 Move 中的一种输入功能，用于控制对给定类型的值允许哪些操作。该系统对值的“线性”类型行为以及值是否以及如何在全局存储中使用提供细粒度控制。这是通过对某些字节码指令的访问进行门控来实现的，因此对于要与字节码指令一起使用的值，它必须具有所需的能力（如果完全需要——不是每条指令都由能力门控）。</p>
<!-- TODO future section on detailed walk through maybe. We have some examples at the end but it might be helpful to explain why we have precisely this set of abilities

If you are already somewhat familiar with abilities from writing Move programs, but are still confused as to what is going on, it might be helpful to skip to the [motivating walkthrough](#motivating-walkthrough) section to get an idea of what the system is setup in the way that it is. -->
<h2 id="the-four-abilities"><a class="header" href="#the-four-abilities">The Four Abilities</a></h2>
<p>The four abilities are:</p>
<h2 id="四种能力"><a class="header" href="#四种能力">四种能力</a></h2>
<p>四种能力分别是：</p>
<ul>
<li><a href="abilities.html#copy"><code>copy</code></a>
<ul>
<li>Allows values of types with this ability to be copied.</li>
<li>允许复制具有此能力的类型的值。</li>
</ul>
</li>
<li><a href="abilities.html#drop"><code>drop</code></a>
<ul>
<li>Allows values of types with this ability to be popped/dropped.</li>
<li>允许弹出/删除具有此能力的类型的值。</li>
</ul>
</li>
<li><a href="abilities.html#store"><code>store</code></a>
<ul>
<li>Allows values of types with this ability to exist inside a struct in global storage.</li>
<li>允许具有这种能力的类型的值存在于全局存储的结构中。</li>
</ul>
</li>
<li><a href="abilities.html#key"><code>key</code></a>
<ul>
<li>Allows the type to serve as a key for global storage operations.</li>
<li>允许该类型作为全局存储操作的键。</li>
</ul>
</li>
</ul>
<h3 id="copy"><a class="header" href="#copy"><code>copy</code></a></h3>
<p>The <code>copy</code> ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the <a href="./variables.html#move-and-copy"><code>copy</code></a> operator and to copy values via references with <a href="./references.html#reading-and-writing-through-references">dereference <code>*e</code></a>.</p>
<p>If a value has <code>copy</code>, all values contained inside of that value have <code>copy</code>.</p>
<p>复制能力允许复制具有该能力的类型的值。它控制了使用复制运算符从局部变量中复制值以及通过取消引用 <code>*e</code> 的引用复制值的能力。</p>
<p>如果一个值有副本，则该值内包含的所有值都有副本。</p>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>The <code>drop</code> ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:</p>
<ul>
<li>not using the value in a local variable or parameter</li>
<li>not using the value in a <a href="./variables.html#expression-blocks">sequence via <code>;</code></a></li>
<li>overwriting values in variables in <a href="./variables.html#assignments">assignments</a></li>
<li>overwriting values via references when <a href="./references.html#reading-and-writing-through-references">writing <code>*e1 = e2</code></a>.</li>
</ul>
<p>If a value has <code>drop</code>, all values contained inside of that value have <code>drop</code>.</p>
<p>丢弃能力允许丢弃具有该能力的类型的值。被丢弃，我们的意思是价值没有被转移，并且在 Move 程序执行时被有效地销毁。因此，此能力限制了在多个位置忽略值的能力，包括：</p>
<ul>
<li>不使用局部变量或参数中的值</li>
<li>不使用序列中的值；</li>
<li>覆盖赋值变量中的值</li>
<li>写入 <code>*e1 = e2</code> 时通过引用覆盖值。</li>
</ul>
<p>如果一个值下降，则该值内包含的所有值都下降。</p>
<h3 id="store"><a class="header" href="#store"><code>store</code></a></h3>
<p>The <code>store</code> ability allows values of types with this ability to exist inside of a struct (resource) in global storage, <em>but</em> not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead it gates the existence in global storage when used in tandem with <code>key</code>.</p>
<p>If a value has <code>store</code>, all values contained inside of that value have <code>store</code></p>
<p>存储能力允许具有这种能力的类型的值存在于全局存储中的结构（资源）内部，但不一定作为全局存储中的顶级资源。这是唯一不直接控制操作的能力。相反，当与 key 一起使用时，它会限制全局存储中的存在。</p>
<p>如果一个值具有存储，则该值内包含的所有值都具有存储</p>
<h3 id="key"><a class="header" href="#key"><code>key</code></a></h3>
<p>The <code>key</code> ability allows the type to serve as a key for <a href="./global-storage-operators.html">global storage operations</a>. It gates all global storage operations, so in order for a type to be used with <code>move_to</code>, <code>borrow_global</code>, <code>move_from</code>, etc., the type must have the <code>key</code> ability. Note that the operations still must be used in the module where the <code>key</code> type is defined (in a sense, the operations are private to the defining module).</p>
<p>If a value has <code>key</code>, all values contained inside of that value have <code>store</code>. This is the only ability with this sort of asymmetry.</p>
<p>密钥能力允许该类型作为全局存储操作的密钥。它对所有全局存储操作进行门控，因此要使类型与 move_to、borrow_global、move_from 等一起使用，该类型必须具有 key 能力。请注意，这些操作仍然必须在定义密钥类型的模块中使用（从某种意义上说，这些操作是定义模块的私有）。</p>
<p>如果一个值有键，则包含在该值内的所有值都有存储。这是唯一具有这种不对称性的能力。</p>
<h2 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h2>
<p>Most primitive, builtin types have <code>copy</code>, <code>drop</code>, and <code>store</code> with the exception of <code>signer</code>, which just has <code>store</code></p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u64</code>, <code>u128</code>, and <code>address</code> all have <code>copy</code>, <code>drop</code>, and <code>store</code>.</li>
<li><code>signer</code> has <code>drop</code>
<ul>
<li>Cannot be copied and cannot be put into global storage</li>
</ul>
</li>
<li><code>vector&lt;T&gt;</code> may have <code>copy</code>, <code>drop</code>, and <code>store</code> depending on the abilities of <code>T</code>.
<ul>
<li>See <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> for more details.</li>
</ul>
</li>
<li>Immutable references <code>&amp;</code> and mutable references <code>&amp;mut</code> both have <code>copy</code> and <code>drop</code>.
<ul>
<li>This refers to copying and dropping the reference itself, not what they refer to.</li>
<li>References cannot appear in global storage, hence they do not have <code>store</code>.</li>
</ul>
</li>
</ul>
<p>None of the primitive types have <code>key</code>, meaning none of them can be used directly with the <a href="./global-storage-operators.html">global storage operations</a>.</p>
<h2 id="内置类型"><a class="header" href="#内置类型">内置类型</a></h2>
<p>大多数原始的内置类型都有复制、删除和存储，但签名者除外，它只有存储</p>
<ul>
<li>bool, u8, u64, u128, 和address都有copy、drop和store。</li>
<li>签名者有下降
<ul>
<li>无法复制，无法放入全局存储</li>
</ul>
</li>
<li>根据 T 的能力，向量 T 可能具有复制、删除和存储。
<ul>
<li>有关更多详细信息，请参阅条件能力和通用类型。</li>
</ul>
</li>
<li>不可变引用 &amp; 和可变引用 &amp;mut 都有复制和删除。
<ul>
<li>这是指复制和删除引用本身，而不是它们所指的内容。</li>
<li>引用不能出现在全局存储中，因此它们没有存储。
所有原始类型都没有键，这意味着它们都不能直接用于全局存储操作。</li>
</ul>
</li>
</ul>
<h2 id="annotating-structs"><a class="header" href="#annotating-structs">Annotating Structs</a></h2>
<p>To declare that a <code>struct</code> has an ability, it is declared with <code>has &lt;ability&gt;</code> after the struct name but before the fields. For example:</p>
<h2 id="注释结构"><a class="header" href="#注释结构">注释结构</a></h2>
<p>要声明结构具有能力，请在结构名称之后但在字段之前使用具有能力来声明它。例如：</p>
<pre><code class="language-move">struct Ignorable has drop { f: u64 }
struct Pair has copy, drop, store { x: u64, y: u64 }
</code></pre>
<p>In this case: <code>Ignorable</code> has the <code>drop</code> ability. <code>Pair</code> has <code>copy</code>, <code>drop</code>, and <code>store</code>.</p>
<p>All of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside of some other collection!</p>
<p>As such: when declaring a struct’s abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...</p>
<ul>
<li><code>copy</code>, all fields must have <code>copy</code>.</li>
<li><code>drop</code>, all fields must have <code>drop</code>.</li>
<li><code>store</code>, all fields must have <code>store</code>.</li>
<li><code>key</code>, all fields must have <code>store</code>.
<ul>
<li><code>key</code> is the only ability currently that doesn’t require itself.</li>
</ul>
</li>
</ul>
<p>For example:
在这种情况下： Ignorable 具有丢弃能力。 Pair 具有复制、删除和存储功能。</p>
<p>所有这些能力对这些门控操作都有强有力的保证。只有具有该能力，才能对值执行操作；即使该值深深嵌套在其他集合中！</p>
<p>因此：在声明结构的能力时，对字段提出了某些要求。所有字段都必须满足这些约束。这些规则是必要的，以便结构满足上述功能的可达性规则。如果一个结构被声明为具有能力......</p>
<ul>
<li>copy，所有字段都必须有副本。</li>
<li>drop，所有字段都必须有drop。</li>
<li>store，所有字段都必须有store。</li>
<li>key，所有字段都必须有存储。
<ul>
<li>key是目前唯一不需要自己的能力。
例如：</li>
</ul>
</li>
</ul>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}
</code></pre>
<p>and similarly:
同样：</p>
<pre><code class="language-move">// A struct without any abilities
struct NoAbilities {}

struct MyResource has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}
</code></pre>
<h2 id="conditional-abilities-and-generic-types"><a class="header" href="#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a></h2>
<p>When abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:</p>
<h2 id="条件能力和通用类型"><a class="header" href="#条件能力和通用类型">条件能力和通用类型</a></h2>
<p>在泛型类型上注释能力时，并非该类型的所有实例都保证具有该能力。考虑这个结构声明：</p>
<pre><code>struct Cup&lt;T&gt; has copy, drop, store, key { item: T }
</code></pre>
<p>It might be very helpful if <code>Cup</code> could hold any type, regardless of its abilities. The type system can <em>see</em> the type parameter, so it should be able to remove abilities from <code>Cup</code> if it <em>sees</em> a type parameter that would violate the guarantees for that ability.</p>
<p>This behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type <code>vector</code> to have the following type declaration:
如果 Cup 可以容纳任何类型，无论其能力如何，这可能会非常有帮助。类型系统可以看到类型参数，因此如果它看到一个类型参数会违反该能力的保证，它应该能够从 Cup 中删除能力。</p>
<p>这种行为一开始可能听起来有点令人困惑，但如果我们考虑一下集合类型，它可能会更容易理解。我们可以考虑内置类型向量具有以下类型声明：</p>
<pre><code>vector&lt;T&gt; has copy, drop, store;
</code></pre>
<p>We want <code>vector</code>s to work with any type. We don't want separate <code>vector</code> types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above.  So, it would be safe to copy a <code>vector</code> value only if the inner elements can be copied. It would be safe to ignore a <code>vector</code> value only if the inner elements can be ignored/dropped. And, it would be safe to put a <code>vector</code> in global storage only if the inner elements can be in global storage.</p>
<p>To have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration <strong>and</strong> its type arguments. For any type, type parameters are pessimistically assumed to be used inside of the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking <code>Cup</code> from above as an example:</p>
<ul>
<li><code>Cup</code> has the ability <code>copy</code> only if <code>T</code> has <code>copy</code>.</li>
<li>It has <code>drop</code> only if <code>T</code> has <code>drop</code>.</li>
<li>It has <code>store</code> only if <code>T</code> has <code>store</code>.</li>
<li>It has <code>key</code> only if <code>T</code> has <code>store</code>.</li>
</ul>
<p>Here are examples for this conditional system for each ability:</p>
<p>我们希望向量适用于任何类型。我们不希望针对不同的能力使用不同的向量类型。那么我们想要的规则是什么？与上面的字段规则完全相同。因此，仅当可以复制内部元素时，复制向量值才是安全的。仅当可以忽略/删除内部元素时，忽略向量值才是安全的。而且，仅当内部元素可以在全局存储中时，将向量放入全局存储中才是安全的。</p>
<p>为了拥有这种额外的表现力，一个类型可能不具备它声明的所有能力，具体取决于该类型的实例化；相反，一个类型的能力取决于它的声明和它的类型参数。对于任何类型，类型参数都被悲观地假定为在结构内部使用，因此只有在类型参数满足上述字段要求时才授予能力。以上面的 Cup 为例：</p>
<ul>
<li>只有 T 有副本，Cup 才有能力副本。</li>
<li>只有当 T 有下降时它才有下降。</li>
<li>只有当 T 有存储时它才有存储。</li>
<li>只有当 T 有存储时它才有密钥。</li>
</ul>
<p>以下是每个能力的条件系统的示例：</p>
<h3 id="example-conditional-copy"><a class="header" href="#example-conditional-copy">Example: conditional <code>copy</code></a></h3>
<pre><code>struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun example(c_x: Cup&lt;u64&gt;, c_s: Cup&lt;S&gt;) {
    // Valid, 'Cup&lt;u64&gt;' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup&lt;S&gt;' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup&lt;signer&gt;, c_n: Cup&lt;NoAbilities&gt;) {
    // Invalid, 'Cup&lt;signer&gt;' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup&lt;NoAbilities&gt;' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
</code></pre>
<h3 id="example-conditional-drop"><a class="header" href="#example-conditional-drop">Example: conditional <code>drop</code></a></h3>
<pre><code>struct NoAbilities {}
struct S has copy, drop { f: bool }
struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun unused() {
    Cup&lt;bool&gt; { item: true }; // Valid, 'Cup&lt;bool&gt;' has 'drop'
    Cup&lt;S&gt; { item: S { f: false }}; // Valid, 'Cup&lt;S&gt;' has 'drop'
}

fun left_in_local(c_account: Cup&lt;signer&gt;): u64 {
    let c_b = Cup&lt;bool&gt; { item: true };
    let c_s = Cup&lt;S&gt; { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup&lt;signer&gt;', 'Cup&lt;bool&gt;', and 'Cup&lt;S&gt;' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup&lt;NoAbilities&gt;' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
}

fun invalid_left_in_local(): u64 {
    let n = Cup&lt;NoAbilities&gt; { item: NoAbilities {}};
    // Invalid return: 'c_n' has a value
    // and 'Cup&lt;NoAbilities&gt;' does not have 'drop'
    0
}
</code></pre>
<h3 id="example-conditional-store"><a class="header" href="#example-conditional-store">Example: conditional <code>store</code></a></h3>
<pre><code>struct Cup&lt;T&gt; has copy, drop, store { item: T }

// 'MyInnerResource' is declared with 'store' so all fields need 'store'
struct MyInnerResource has store {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}

// 'MyResource' is declared with 'key' so all fields need 'store'
struct MyResource has key {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    inner: Cup&lt;MyInnerResource&gt;, // Valid, 'Cup&lt;MyInnerResource&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}
</code></pre>
<h3 id="example-conditional-key"><a class="header" href="#example-conditional-key">Example: conditional <code>key</code></a></h3>
<pre><code>struct NoAbilities {}
struct MyResource&lt;T&gt; has key { f: T }

fun valid(account: &amp;signer) acquires MyResource {
    let addr = signer::address_of(account);
     // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let has_resource = exists&lt;MyResource&lt;u64&gt;&gt;(addr);
    if (!has_resource) {
         // Valid, 'MyResource&lt;u64&gt;' has 'key'
        move_to(account, MyResource&lt;u64&gt; { f: 0 })
    };
    // Valid, 'MyResource&lt;u64&gt;' has 'key'
    let r = borrow_global_mut&lt;MyResource&lt;u64&gt;&gt;(addr)
    r.f = r.f + 1;
}

fun invalid(account: &amp;signer) {
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let has_it = exists&lt;MyResource&lt;NoAbilities&gt;&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   let NoAbilities {} = move_from&lt;NoAbilities&gt;(addr);
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   move_to(account, NoAbilities {});
   // Invalid, 'MyResource&lt;NoAbilities&gt;' does not have 'key'
   borrow_global&lt;NoAbilities&gt;(addr);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uses-and-aliases"><a class="header" href="#uses-and-aliases">Uses and Aliases</a></h1>
<p>The <code>use</code> syntax can be used to create aliases to members in other modules. <code>use</code> can be used to
create aliases that last either for the entire module, or for a given expression block scope.</p>
<h1 id="用途和别名"><a class="header" href="#用途和别名">用途和别名</a></h1>
<p>use 语法可用于为其他模块中的成员创建别名。 use 可用于为整个模块或给定的表达式块范围创建别名。</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>There are several different syntax cases for <code>use</code>. Starting with the most simple, we have the
following for creating aliases to other modules</p>
<h2 id="句法"><a class="header" href="#句法">句法</a></h2>
<p>有几种不同的语法案例可供使用。从最简单的开始，我们有以下用于为其他模块创建别名</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;;
use &lt;address&gt;::&lt;module name&gt; as &lt;module alias name&gt;;
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move">use std::vector;
use std::vector as V;
</code></pre>
<p><code>use std::vector;</code> introduces an alias <code>vector</code> for <code>std::vector</code>. This means that anywhere you
would want to use the module name <code>std::vector</code> (assuming this <code>use</code> is in scope), you could use
<code>vector</code> instead. <code>use std::vector;</code> is equivalent to <code>use std::vector as vector;</code></p>
<p>Similarly <code>use std::vector as V;</code> would let you use <code>V</code> instead of <code>std::vector</code></p>
<p>使用标准::向量；为 std::vector 引入别名向量。这意味着在任何您想使用模块名称 std::vector 的地方（假设此使用在范围内），您都可以使用 vector 代替。使用标准::向量；相当于使用 std::vector 作为向量；</p>
<p>同样使用 std::vector 作为 V;会让你使用 V 而不是 std::vector</p>
<pre><code class="language-move=">use std::vector;
use std::vector as V;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = vector::empty();
    let v3 = V::empty();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to import a specific module member (such as a function, struct, or constant). You can
use the following syntax.</p>
<p>如果要导入特定的模块成员（例如函数、结构或常量）。您可以使用以下语法。</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt;;
use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt; as &lt;member alias&gt;;
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move">use std::vector::empty;
use std::vector::empty as empty_vec;
</code></pre>
<p>This would let you use the function <code>std::vector::empty</code> without full qualification. Instead you
could use <code>empty</code> and <code>empty_vec</code> respectively. Again, <code>use std::vector::empty;</code> is equivalent to
<code>use std::vector::empty as empty;</code></p>
<p>这将允许您在没有完全限定的情况下使用函数 std::vector::empty。相反，您可以分别使用 empty 和 empty_vec。再次，使用 std::vector::empty;相当于使用 std::vector::empty 作为空；</p>
<pre><code class="language-move=">use std::vector::empty;
use std::vector::empty as empty_vec;

fun new_vecs(): (vector&lt;u8&gt;, vector&lt;u8&gt;, vector&lt;u8&gt;) {
    let v1 = std::vector::empty();
    let v2 = empty();
    let v3 = empty_vec();
    (v1, v2, v3)
}
</code></pre>
<p>If you want to add aliases for multiple module members at once, you can do so with the following
syntax</p>
<p>如果要一次为多个模块成员添加别名，可以使用以下语法</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::{&lt;module member&gt;, &lt;module member&gt; as &lt;member alias&gt; ... };
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move=">use std::vector::{push_back, length as len, pop_back};

fun swap_last_two&lt;T&gt;(v: &amp;mut vector&lt;T&gt;) {
    assert!(len(v) &gt;= 2, 42);
    let last = pop_back(v);
    let second_to_last = pop_back(v);
    push_back(v, last);
    push_back(v, second_to_last)
}
</code></pre>
<p>If you need to add an alias to the Module itself in addition to module members, you can do that in a
single <code>use</code> using <code>Self</code>. <code>Self</code> is a member of sorts that refers to the module.</p>
<p>如果除了模块成员之外，您还需要为模块本身添加别名，您可以使用 Self 一次性完成。 Self 是指模块的各种成员。</p>
<pre><code class="language-move">use std::vector::{Self, empty};
</code></pre>
<p>For clarity, all of the following are equivalent:</p>
<p>为清楚起见，以下所有内容都是等效的：</p>
<pre><code class="language-move">use std::vector;
use std::vector as vector;
use std::vector::Self;
use std::vector::Self as vector;
use std::vector::{Self};
use std::vector::{Self as vector};
</code></pre>
<p>If needed, you can have as many aliases for any item as you like</p>
<p>如果需要，您可以为任何项目设置任意数量的别名</p>
<pre><code class="language-move=">use std::vector::{
    Self,
    Self as V,
    length,
    length as len,
};

fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    // all options available given the `use` above
    assert!(vector::length(v) &gt; 1, 42);
    assert!(V::length(v) &gt; 1, 42);
    assert!(length(v) &gt; 1, 42);
    assert!(len(v) &gt; 1, 42);

    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<h2 id="inside-a-module"><a class="header" href="#inside-a-module">Inside a <code>module</code></a></h2>
<p>Inside of a <code>module</code> all <code>use</code> declarations are usable regardless of the order of declaration.</p>
<h2 id="模块内部"><a class="header" href="#模块内部">模块内部</a></h2>
<p>在模块内部，无论声明顺序如何，所有 use 声明都是可用的。</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector;

    fun example(): vector&lt;u8&gt; {
        let v = empty();
        vector::push_back(&amp;mut v, 0);
        vector::push_back(&amp;mut v, 10);
        v
    }

    use std::vector::empty;
}
}
</code></pre>
<p>The aliases declared by <code>use</code> in the module usable within that module.</p>
<p>Additionally, the aliases introduced cannot conflict with other module members. See
<a href="uses.html#uniqueness">Uniqueness</a> for more details</p>
<p>在该模块中可用的模块中使用声明的别名。</p>
<p>此外，引入的别名不能与其他模块成员冲突。有关详细信息，请参阅唯一性</p>
<h2 id="inside-an-expression"><a class="header" href="#inside-an-expression">Inside an expression</a></h2>
<p>You can add <code>use</code> declarations to the beginning of any expression block</p>
<h2 id="在表达式内部"><a class="header" href="#在表达式内部">在表达式内部</a></h2>
<p>您可以将 use 声明添加到任何表达式块的开头</p>
<pre><code class="language-move=">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        use std::vector::{empty, push_back};

        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    }
}
}
</code></pre>
<p>As with <code>let</code>, the aliases introduced by <code>use</code> in an expression block are removed at the end of that
block.</p>
<p>与 let 一样，在表达式块中使用 use 引入的别名在该块的末尾被删除。</p>
<pre><code class="language-move=">address 0x42 {
module example {

    fun example(): vector&lt;u8&gt; {
        let result = {
            use std::vector::{empty, push_back};
            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 10);
            v
        };
        result
    }

}
}
</code></pre>
<p>Attempting to use the alias after the block ends will result in an error</p>
<p>在块结束后尝试使用别名将导致错误</p>
<pre><code class="language-move=">fun example(): vector&lt;u8&gt; {
    let result = {
        use std::vector::{empty, push_back};
        let v = empty();
        push_back(&amp;mut v, 0);
        push_back(&amp;mut v, 10);
        v
    };
    let v2 = empty(); // ERROR!
//           ^^^^^ unbound function 'empty'
    result
}
</code></pre>
<p>Any <code>use</code> must be the first item in the block. If the <code>use</code> comes after any expression or <code>let</code>, it
will result in a parsing error</p>
<p>任何使用都必须是块中的第一项。如果 use 出现在任何表达式或 let 之后，则会导致解析错误</p>
<pre><code class="language-move=">{
    let x = 0;
    use std::vector; // ERROR!
    let v = vector::empty();
}
</code></pre>
<h2 id="naming-rules"><a class="header" href="#naming-rules">Naming rules</a></h2>
<p>Aliases must follow the same rules as other module members. This means that aliases to structs or
constants must start with <code>A</code> to <code>Z</code></p>
<h2 id="命名规则"><a class="header" href="#命名规则">命名规则</a></h2>
<p>别名必须遵循与其他模块成员相同的规则。这意味着结构或常量的别名必须以 A 到 Z 开头</p>
<pre><code class="language-move=">address 0x42 {
module data {
    struct S {}
    const FLAG: bool = false;
    fun foo() {}
}
module example {
    use 0x42::data::{
        S as s, // ERROR!
        FLAG as fLAG, // ERROR!
        foo as FOO,  // valid
        foo as bar, // valid
    };
}
}
</code></pre>
<h2 id="uniqueness"><a class="header" href="#uniqueness">Uniqueness</a></h2>
<p>Inside a given scope, all aliases introduced by <code>use</code> declarations must be unique.</p>
<p>For a module, this means aliases introduced by <code>use</code> cannot overla</p>
<h2 id="独特性"><a class="header" href="#独特性">独特性</a></h2>
<p>在给定范围内，所有由 use 声明引入的别名必须是唯一的。</p>
<p>对于一个模块，这意味着使用引入的别名不能重叠</p>
<pre><code class="language-move=">address 0x42 {
module example {

    use std::vector::{empty as foo, length as foo}; // ERROR!
    //                                        ^^^ duplicate 'foo'

    use std::vector::empty as bar;

    use std::vector::length as bar; // ERROR!
    //                         ^^^ duplicate 'bar'

}
}
</code></pre>
<p>And, they cannot overlap with any of the module's other members</p>
<p>而且，它们不能与模块的任何其他成员重叠</p>
<pre><code class="language-move=">address 0x42 {
module data {
    struct S {}
}
module example {
    use 0x42::data::S;

    struct S { value: u64 } // ERROR!
    //     ^ conflicts with alias 'S' above
}
}
</code></pre>
<p>Inside of an expression block, they cannot overlap with each other, but they can
<a href="uses.html#shadowing">shadow</a> other aliases or names from an outer scope</p>
<p>在表达式块内部，它们不能相互重叠，但它们可以遮蔽外部作用域中的其他别名或名称</p>
<h2 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h2>
<p><code>use</code> aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;</p>
<h2 id="隐藏-1"><a class="header" href="#隐藏-1">隐藏</a></h2>
<p>在表达式块内使用别名可以隐藏外部范围的名称（模块成员或别名）。与局部变量的隐藏一样，阴影在表达式块的末尾结束；</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct WrappedVector { vec: vector&lt;u64&gt; }

    fun empty(): WrappedVector {
        WrappedVector { vec: std::vector::empty() }
    }

    fun example1(): (WrappedVector, WrappedVector) {
        let vec = {
            use std::vector::{empty, push_back};
            // 'empty' now refers to std::vector::empty

            let v = empty();
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 1);
            push_back(&amp;mut v, 10);
            v
        };
        // 'empty' now refers to Self::empty

        (empty(), WrappedVector { vec })
    }

    fun example2(): (WrappedVector, WrappedVector) {
        use std::vector::{empty, push_back};
        let w: WrappedVector = {
            use 0x42::example::empty;
            empty()
        };
        push_back(&amp;mut w.vec, 0);
        push_back(&amp;mut w.vec, 1);
        push_back(&amp;mut w.vec, 10);

        let vec = empty();
        push_back(&amp;mut vec, 0);
        push_back(&amp;mut vec, 1);
        push_back(&amp;mut vec, 10);

        (w, WrappedVector { vec })
    }
}
}
</code></pre>
<h2 id="unused-use-or-alias"><a class="header" href="#unused-use-or-alias">Unused Use or Alias</a></h2>
<p>An unused <code>use</code> will result in an error</p>
<h2 id="未使用的使用或别名"><a class="header" href="#未使用的使用或别名">未使用的使用或别名</a></h2>
<p>未使用会导致错误</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector::{empty, push_back}; // ERROR!
    //                       ^^^^^^^^^ unused alias 'push_back'

    fun example(): vector&lt;u8&gt; {
        empty()
    }
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="friends"><a class="header" href="#friends">Friends</a></h1>
<p>The <code>friend</code> syntax is used to declare modules that are trusted by the current module.
A trusted module is allowed to call any function defined in the current module that have the <code>public(friend)</code> visibility.
For details on function visibilities, please refer to the <em>Visibility</em> section in <a href="./functions.html">Functions</a>.</p>
<h1 id="友元"><a class="header" href="#友元">友元</a></h1>
<p>友元语法用于声明当前模块信任的模块。允许受信任的模块调用当前模块中定义的任何具有公共（朋友）可见性的函数。有关函数可见性的详细信息，请参阅函数中的可见性部分。</p>
<h2 id="friend-declaration"><a class="header" href="#friend-declaration">Friend declaration</a></h2>
<p>A module can declare other modules as friends via friend declaration statements, in the format of</p>
<ul>
<li><code>friend &lt;address::name&gt;</code> — friend declaration using fully qualified module name like the example below, or</li>
</ul>
<h2 id="友元声明"><a class="header" href="#友元声明">友元声明</a></h2>
<p>一个模块可以通过友元声明语句将其他模块声明为友元，格式为</p>
<ul>
<li>
<p><code>friend &lt;address::name&gt;</code> — 使用完全限定模块名称的朋友声明，如下例所示，或</p>
<pre><code class="language-move">address 0x42 {
module a {
    friend 0x42::b;
}
}
</code></pre>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;</code> — friend declaration using a module name alias, where the module alias is introduced via the <code>use</code> statement.</p>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;</code>——使用模块名称别名的朋友声明，其中模块别名是通过 use 语句引入的。</p>
<pre><code class="language-move">address 0x42 {
module a {
    use 0x42::b;
    friend b;
}
}
</code></pre>
</li>
</ul>
<p>A module may have multiple friend declarations, and the union of all the friend modules forms the friend list.
In the example below, both <code>0x42::B</code> and <code>0x42::C</code> are considered as friends of <code>0x42::A</code>.</p>
<p>一个模块可能有多个好友声明，所有好友模块的并集形成好友列表。在下面的示例中，0x42::B 和 0x42::C 都被视为 0x42::A 的朋友。</p>
<pre><code class="language-move">address 0x42 {
module a {
    friend 0x42::b;
    friend 0x42::c;
}
}
</code></pre>
<p>Unlike <code>use</code> statements, <code>friend</code> can only be declared in the module scope and not in the expression block scope.
<code>friend</code> declarations may be located anywhere a top-level construct (e.g., <code>use</code>, <code>function</code>, <code>struct</code>, etc.) is allowed.
However, for readability, it is advised to place friend declarations near the beginning of the module definition.</p>
<p>Note that the concept of friendship does not apply to Move scripts:</p>
<ul>
<li>A Move script cannot declare <code>friend</code> modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.</li>
<li>A Move module cannot declare <code>friend</code> scripts as well because scripts are ephemeral code snippets that are never published to global storage.</li>
</ul>
<p>与 use 语句不同，friend 只能在模块范围内声明，而不能在表达式块范围内声明。友元声明可以位于允许顶级构造（例如，使用、函数、结构等）的任何地方。但是，为了可读性，建议将友元声明放在模块定义的开头附近。</p>
<p>请注意，友谊的概念不适用于 Move 脚本：</p>
<ul>
<li>Move 脚本不能声明友元模块，因为这样做被认为是没有意义的：没有调用脚本中定义的函数的机制。</li>
<li>Move 模块也不能声明友元脚本，因为脚本是临时代码片段，从未发布到全局存储。</li>
</ul>
<h3 id="friend-declaration-rules"><a class="header" href="#friend-declaration-rules">Friend declaration rules</a></h3>
<p>Friend declarations are subject to the following rules:</p>
<ul>
<li>A module cannot declare itself as a friend.</li>
</ul>
<h3 id="好友声明规则"><a class="header" href="#好友声明规则">好友声明规则</a></h3>
<p>朋友声明须遵守以下规则：</p>
<ul>
<li>
<p>模块不能将自己声明为友元。</p>
<pre><code class="language-move=">address 0x42 {
module m { friend Self; // ERROR! }
//                ^^^^ Cannot declare the module itself as a friend
}

address 0x43 {
module m { friend 0x43::M; // ERROR! }
//                ^^^^^^^ Cannot declare the module itself as a friend
}
</code></pre>
</li>
<li>
<p>Friend modules must be known by the compiler</p>
</li>
<li>
<p>编译器必须知道友元模块</p>
<pre><code class="language-move=">address 0x42 {
module m { friend 0x42::nonexistent; // ERROR! }
//                ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'
}
</code></pre>
</li>
<li>
<p>Friend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which <em>may</em> be relaxed later.)</p>
</li>
<li>
<p>好友模块必须在同一个账户地址内。 （注：这不是技术要求，而是以后可能放宽的政策决定。）</p>
<pre><code class="language-move=">address 0x42 {
module m {}
}

address 0x43 {
module n { friend 0x42::m; // ERROR! }
//                ^^^^^^^ Cannot declare modules out of the current address as a friend
}
</code></pre>
</li>
<li>
<p>Friends relationships cannot create cyclic module dependencies.</p>
<p>Cycles are not allowed in the friend relationships, e.g., the relation <code>0x2::a</code> friends <code>0x2::b</code> friends <code>0x2::c</code> friends <code>0x2::a</code> is not allowed.
More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module).
If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.</p>
</li>
<li>
<p>朋友关系不能创建循环模块依赖关系。</p>
</li>
</ul>
<p>朋友关系中不允许循环，例如，关系 0x2::a 朋友 0x2::b 朋友 0x2::c 朋友 0x2::a 是不允许的。更一般地，声明一个友元模块会将对当前模块的依赖添加到友元模块（因为目的是让友元调用当前模块中的函数）。如果该友元模块已被直接或传递地使用，则将创建一个依赖循环。</p>
<pre><code class="language-move=">address 0x2 {
module a {
    use 0x2::c;
    friend 0x2::b;

    public fun a() {
        c::c()
    }
}

module b {
    friend 0x2::c; // ERROR!
//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'
}

module c {
    public fun c() {}
}
}
</code></pre>
<ul>
<li>
<p>The friend list for a module cannot contain duplicates.</p>
</li>
<li>
<p>模块的好友列表不能包含重复项。</p>
<pre><code class="language-move=">address 0x42 {
module a {}

module m {
    use 0x42::a as aliased_a;
    friend 0x42::A;
    friend aliased_a; // ERROR!
//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique
}
}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Packages allow Move programmers to more easily re-use code and share it
across projects. The Move package system allows programmers to easily:</p>
<ul>
<li>Define a package containing Move code;</li>
<li>Parameterize a package by <a href="./address.html">named addresses</a>;</li>
<li>Import and use packages in other Move code and instantiate named addresses;</li>
<li>Build packages and generate associated compilation artifacts from packages; and</li>
<li>Work with a common interface around compiled Move artifacts.</li>
</ul>
<h1 id="包"><a class="header" href="#包">包</a></h1>
<p>包允许 Move 程序员更轻松地重用代码并在项目之间共享。 Move 包系统允许程序员轻松地：</p>
<ul>
<li>定义一个包含移动代码的包；</li>
<li>通过命名地址参数化包；</li>
<li>在其他 Move 代码中导入和使用包并实例化命名地址；</li>
<li>构建包并从包中生成相关的编译工件；和</li>
<li>使用围绕已编译 Move 工件的通用接口。</li>
</ul>
<h2 id="package-layout-and-manifest-syntax"><a class="header" href="#package-layout-and-manifest-syntax">Package Layout and Manifest Syntax</a></h2>
<p>A Move package source directory contains a <code>Move.toml</code> package manifest
file along with a set of subdirectories:</p>
<h2 id="包布局和清单语法"><a class="header" href="#包布局和清单语法">包布局和清单语法</a></h2>
<p>Move 包源目录包含一个 Move.toml 包清单文件以及一组子目录：</p>
<pre><code>a_move_package
├── Move.toml      (required)
├── sources        (required)
├── examples       (optional, test &amp; dev mode)
├── scripts        (optional)
├── doc_templates  (optional)
└── tests          (optional, test mode)
</code></pre>
<p>The directories marked <code>required</code> <em>must</em> be present in order for the directory
to be considered a Move package and to be compiled. Optional directories can
be present, and if so will be included in the compilation process. Depending on
the mode that the package is built with (<code>test</code> or <code>dev</code>), the <code>tests</code> and
<code>examples</code> directories will be included as well.</p>
<p>The <code>sources</code> directory can contain both Move modules and Move scripts (both
transaction scripts and modules containing script functions). The <code>examples</code>
directory can hold additional code to be used only for development and/or
tutorial purposes that will not be included when compiled outside <code>test</code> or
<code>dev</code> mode.</p>
<p>A <code>scripts</code> directory is supported so transaction scripts can be separated
from modules if that is desired by the package author. The <code>scripts</code>
directory will always be included for compilation if it is present.
Documentation will be built using any documentation templates present in
the <code>doc_templates</code> directory.</p>
<p>必须存在标记为必需的目录才能将该目录视为 Move 包并进行编译。可以存在可选目录，如果存在，将包含在编译过程中。根据构建包的模式（测试或开发），测试和示例目录也将包括在内。</p>
<p>源目录可以包含移动模块和移动脚本（事务脚本和包含脚本函数的模块）。示例目录可以包含仅用于开发和/或教程目的的附加代码，这些代码在测试或开发模式之外编译时不会包含在内。</p>
<p>支持脚本目录，因此如果包作者需要，可以将事务脚本与模块分开。如果存在脚本目录，则将始终包含它以进行编译。将使用 doc_templates 目录中存在的任何文档模板构建文档。</p>
<h3 id="movetoml"><a class="header" href="#movetoml">Move.toml</a></h3>
<p>The Move package manifest is defined within the <code>Move.toml</code> file and has the
following syntax. Optional fields are marked with <code>*</code>, <code>+</code> denotes
one or more elements:</p>
<p>Move 包清单在 Move.toml 文件中定义，并具有以下语法。可选字段标有 <code>*</code>，<code>+</code> 表示一个或多个元素：</p>
<pre><code>[package]
name = &lt;string&gt;                  # e.g., &quot;MoveStdlib&quot;
version = &quot;&lt;uint&gt;.&lt;uint&gt;.&lt;uint&gt;&quot; # e.g., &quot;0.1.1&quot;
license* = &lt;string&gt;              # e.g., &quot;MIT&quot;, &quot;GPL&quot;, &quot;Apache 2.0&quot;
authors* = [&lt;string&gt;]            # e.g., [&quot;Joe Smith (joesmith@noemail.com)&quot;, &quot;Jane Smith (janesmith@noemail.com)&quot;]

[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph
# One or more lines declaring named addresses in the following format
&lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency
# One or more lines declaring dependencies in the following format
&lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # local dependencies
&lt;string&gt; = { git = &lt;URL ending in .git&gt;, subdir=&lt;path to dir containing Move.toml inside git repo&gt;, rev=&lt;git commit hash&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ } } # git dependencies

[dev-addresses] # (Optional section) Same as [addresses] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# One or more lines declaring dev named addresses in the following format
&lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# One or more lines declaring dev dependencies in the following format
&lt;string&gt; = { local = &lt;string&gt;, addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &lt;address&gt;))+ } }
</code></pre>
<p>An example of a minimal package manifest with one local dependency and one git dependency:</p>
<p>具有一个本地依赖项和一个 git 依赖项的最小包清单示例：</p>
<pre><code>[package]
name = &quot;AName&quot;
version = &quot;0.0.0&quot;
</code></pre>
<p>An example of a more standard package manifest that also includes the Move
standard library and instantiates the named address <code>Std</code> from it with the
address value <code>0x1</code>:</p>
<p>一个更标准的包清单示例，它还包括 Move 标准库，并使用地址值 0x1 从中实例化命名地址 Std：</p>
<pre><code>[package]
name = &quot;AName&quot;
version = &quot;0.0.0&quot;
license = &quot;Apache 2.0&quot;

[addresses]
address_to_be_filled_in = &quot;_&quot;
specified_address = &quot;0xB0B&quot;

[dependencies]
# Local dependency
LocalDep = { local = &quot;projects/move-awesomeness&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
# Git dependency
MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot; }

[dev-addresses] # For use when developing this module
address_to_be_filled_in = &quot;0x101010101&quot;
</code></pre>
<p>Most of the sections in the package manifest are self explanatory, but named
addresses can be a bit difficult to understand so it's worth examining them in
a bit more detail.</p>
<p>包清单中的大多数部分都是不言自明的，但命名地址可能有点难以理解，因此值得更详细地检查它们。</p>
<h2 id="named-addresses-during-compilation"><a class="header" href="#named-addresses-during-compilation">Named Addresses During Compilation</a></h2>
<p>Recall that Move has <a href="./address.html">named addresses</a> and that
named addresses cannot be declared in Move. Because of this, until now
named addresses and their values needed to be passed to the compiler on the
command line. With the Move package system this is no longer needed, and
you can declare named addresses in the package, instantiate other named
addresses in scope, and rename named addresses from other packages within
the Move package system manifest file. Let's go through each of these
individually:</p>
<h2 id="编译期间的命名地址"><a class="header" href="#编译期间的命名地址">编译期间的命名地址</a></h2>
<p>回想一下，Move 具有命名地址，并且不能在 Move 中声明命名地址。因此，到目前为止，命名地址及其值都需要在命令行上传递给编译器。使用 Move 包系统，这不再需要，您可以在包中声明命名地址，实例化范围内的其他命名地址，并从 Move 包系统清单文件中的其他包重命名命名地址。让我们分别来看看这些：</p>
<h3 id="declaration-2"><a class="header" href="#declaration-2">Declaration</a></h3>
<p>Let's say we have a Move module in <code>example_pkg/sources/A.move</code> as follows:</p>
<h3 id="声明-3"><a class="header" href="#声明-3">声明</a></h3>
<p>假设我们在 example_pkg/sources/A.move 中有一个 Move 模块，如下所示：</p>
<pre><code class="language-move">module named_addr::A {
    public fun x(): address { @named_addr }
}
</code></pre>
<p>We could in <code>example_pkg/Move.toml</code> declare the named address <code>named_addr</code> in
two different ways. The first:</p>
<p>我们可以在 example_pkg/Move.toml 中以两种不同的方式声明命名地址 named_addr。首先：</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;_&quot;
</code></pre>
<p>Declares <code>named_addr</code> as a named address in the package <code>ExamplePkg</code> and
that <em>this address can be any valid address value</em>. Therefore an importing
package can pick the value of the named address <code>named_addr</code> to be any address
it wishes. Intuitively you can think of this as parameterizing the package
<code>ExamplePkg</code> by the named address <code>named_addr</code>, and the package can then be
instantiated later on by an importing package.</p>
<p><code>named_addr</code> can also be declared as:</p>
<p>将 named_addr 声明为包 ExamplePkg 中的命名地址，并且该地址可以是任何有效的地址值。因此，导入包可以选择命名地址 named_addr 的值作为它希望的任何地址。直观地，您可以将其视为通过命名地址named_addr参数化包ExamplePkg，然后可以稍后通过导入包来实例化该包。</p>
<p>named_addr 也可以声明为：</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;0xCAFE&quot;
</code></pre>
<p>which states that the named address <code>named_addr</code> is exactly <code>0xCAFE</code> and cannot be
changed. This is useful so other importing packages can use this named
address without needing to worry about the exact value assigned to it.</p>
<p>With these two different declaration methods, there are two ways that
information about named addresses can flow in the package graph:</p>
<ul>
<li>The former (&quot;unassigned named addresses&quot;) allows named address values to flow
from the importation site to the declaration site.</li>
<li>The latter (&quot;assigned named addresses&quot;) allows named address values to flow
from the declaration site upwards in the package graph to usage sites.</li>
</ul>
<p>With these two methods for flowing named address information throughout the
package graph the rules around scoping and renaming become important to
understand.</p>
<p>其中指出命名地址 named_addr 正好是 0xCAFE 并且不能更改。这很有用，因此其他导入包可以使用这个命名地址，而无需担心分配给它的确切值。</p>
<p>使用这两种不同的声明方法，有关命名地址的信息可以通过两种方式在包图中流动：</p>
<ul>
<li>前者（“未分配的命名地址”）允许命名地址值从进口站点流向申报站点。</li>
<li>后者（“分配的命名地址”）允许命名地址值从包图中的声明站点向上流动到使用站点。</li>
</ul>
<p>通过这两种在整个包图中流动命名地址信息的方法，了解范围和重命名的规则变得很重要。</p>
<h2 id="scoping-and-renaming-of-named-addresses"><a class="header" href="#scoping-and-renaming-of-named-addresses">Scoping and Renaming of Named Addresses</a></h2>
<p>A named address <code>N</code> in a package <code>P</code> is in scope if:</p>
<ol>
<li>It declares a named address <code>N</code>; or</li>
<li>A package in one of <code>P</code>'s transitive dependencies declares the named address
<code>N</code> and there is a dependency path in the package graph between between <code>P</code> and the
declaring package of <code>N</code> with no renaming of <code>N</code>.</li>
</ol>
<p>Additionally, every named address in a package is exported. Because of this and
the above scoping rules each package can be viewed as coming with a set of
named addresses that will be brought into scope when the package is imported,
e.g., if the <code>ExamplePkg</code> package was imported, that importation would bring
into scope the <code>named_addr</code> named address. Because of this, if <code>P</code> imports two
packages <code>P1</code> and <code>P2</code> both of which declare a named address <code>N</code> an issue
arises in <code>P</code>: which &quot;<code>N</code>&quot; is meant when <code>N</code> is referred to in <code>P</code>? The one
from <code>P1</code> or <code>P2</code>? To prevent this ambiguity around which package a named
address is coming from, we enforce that the sets of scopes introduced by all
dependencies in a package are disjoint, and provide a way to <em>rename named
addresses</em> when the package that brings them into scope is imported.</p>
<p>Renaming a named address when importing can be done as follows in our <code>P</code>,
<code>P1</code>, and <code>P2</code> example above:</p>
<h2 id="命名地址的范围和重命名"><a class="header" href="#命名地址的范围和重命名">命名地址的范围和重命名</a></h2>
<p>包 P 中的命名地址 N 在范围内，如果：</p>
<ol>
<li>它声明了一个命名地址N；或者</li>
<li>P 的传递依赖项之一中的包声明了命名地址 N，并且在 P 和声明 N 的包之间的包图中存在一条依赖路径，没有重命名 N。</li>
</ol>
<p>此外，包中的每个命名地址都会被导出。由于这个和上述范围规则，每个包都可以被视为带有一组命名地址，这些地址将在导入包时被纳入范围，例如，如果导入了 ExamplePkg 包，则该导入会将 named_addr 纳入范围命名地址。正因为如此，如果 P 导入两个包 P1 和 P2，这两个包都声明了一个命名地址 N，那么 P 中就会出现问题：当 P 中引用 N 时，哪个“N”是指？ P1还是P2的那个？为了防止命名地址来自哪个包的这种歧义，我们强制一个包中所有依赖项引入的范围集是不相交的，并提供一种在将命名地址带入范围的包被导入时重命名命名地址的方法。</p>
<p>在我们上面的 P、P1 和 P2 示例中，可以在导入时重命名命名地址，如下所示：</p>
<pre><code>[package]
name = &quot;P&quot;
...
[dependencies]
P1 = { local = &quot;some_path_to_P1&quot;, addr_subst = { &quot;P1N&quot; = &quot;N&quot; } }
P2 = { local = &quot;some_path_to_P2&quot;  }
</code></pre>
<p>With this renaming <code>N</code> refers to the <code>N</code> from <code>P2</code> and <code>P1N</code> will refer to <code>N</code>
coming from <code>P1</code>:</p>
<p>通过这个重命名，N 指的是来自 P2 的 N，而 P1N 将指的是来自 P1 的 N：</p>
<pre><code>module N::A {
    public fun x(): address { @P1N }
}
</code></pre>
<p>It is important to note that <em>renaming is not local</em>: once a named address <code>N</code>
has been renamed to <code>N2</code> in a package <code>P</code> all packages that import <code>P</code> will not
see <code>N</code> but only <code>N2</code> unless <code>N</code> is reintroduced from outside of <code>P</code>. This is
why rule (2) in the scoping rules at the start of this section specifies a
&quot;dependency path in the package graph between between <code>P</code> and the declaring
package of <code>N</code> with no renaming of <code>N</code>.&quot;</p>
<p>重要的是要注意重命名不是本地的：一旦在包 P 中将命名地址 N 重命名为 N2，所有导入 P 的包都不会看到 N，而只会看到 N2，除非从 P 外部重新引入 N。这就是为什么规则(2) 在本节开头的作用域规则中指定了“包图中 P 和 N 的声明包之间的依赖路径，没有重命名 N。”</p>
<h3 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h3>
<p>Named addresses can be instantiated multiple times across the package graph as
long as it is always with the same value. It is an error if the same named
address (regardless of renaming) is instantiated with differing values across
the package graph.</p>
<p>A Move package can only be compiled if all named addresses resolve to a value.
This presents issues if the package wishes to expose an uninstantiated named
address. This is what the <code>[dev-addresses]</code> section solves. This section can
set values for named addresses, but cannot introduce any named addresses.
Additionally, only the <code>[dev-addresses]</code> in the root package are included in
<code>dev</code> mode. For example a root package with the following manifest would not compile
outside of <code>dev</code> mode since <code>named_addr</code> would be uninstantiated:</p>
<h3 id="实例化-1"><a class="header" href="#实例化-1">实例化</a></h3>
<p>只要命名地址始终具有相同的值，就可以在包图中多次实例化命名地址。如果在整个包图中使用不同的值实例化相同的命名地址（无论是否重命名），则会出现错误。</p>
<p>只有当所有命名地址都解析为一个值时，才能编译 Move 包。如果包希望公开未实例化的命名地址，则会出现问题。这就是 [dev-addresses] 部分解决的问题。本节可以设置命名地址的值，但不能引入任何命名地址。此外，只有根包中的 [dev-addresses] 包含在开发模式中。例如，具有以下清单的根包不会在开发模式之外编译，因为 named_addr 将未实例化：</p>
<pre><code>[package]
name = &quot;ExamplePkg&quot;
...
[addresses]
named_addr = &quot;_&quot;

[dev-addresses]
named_addr = &quot;0xC0FFEE&quot;
</code></pre>
<h2 id="usage-artifacts-and-data-structures"><a class="header" href="#usage-artifacts-and-data-structures">Usage, Artifacts, and Data Structures</a></h2>
<p>The Move package system comes with a command line option as part of the Move
CLI <code>move &lt;flags&gt; &lt;command&gt; &lt;command_flags&gt;</code>. Unless a
particular path is provided, all package commands will run in the current working
directory. The full list of commands and flags for the Move CLI can be found by
running <code>move --help</code>.</p>
<h2 id="用法工件和数据结构"><a class="header" href="#用法工件和数据结构">用法、工件和数据结构</a></h2>
<p>Move 包系统附带一个命令行选项，作为 Move CLI 移动标志命令 command_flags 的一部分。除非提供特定路径，否则所有包命令都将在当前工作目录中运行。可以通过运行 move --help 找到 Move CLI 的命令和标志的完整列表。</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>A package can be compiled either through the Move CLI commands, or as a library
command in Rust with the function <code>compile_package</code>. This will create a
<code>CompiledPackage</code> that holds the compiled bytecode along with other compilation
artifacts (source maps, documentation, ABIs) in memory. This <code>CompiledPackage</code>
can be converted to an <code>OnDiskPackage</code> and vice versa -- the latter being the data of
the <code>CompiledPackage</code> laid out in the file system in the following format:</p>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p>可以通过 Move CLI 命令编译包，也可以使用函数 compile_package 在 Rust 中编译为库命令。这将创建一个 CompiledPackage，它在内存中保存已编译的字节码以及其他编译工件（源映射、文档、ABI）。这个 CompiledPackage 可以转换为 OnDiskPackage ，反之亦然 - 后者是 CompiledPackage 的数据，以下列格式在文件系统中布局：</p>
<pre><code>a_move_package
├── Move.toml
...
└── build
    ├── &lt;dep_pkg_name&gt;
    │   ├── BuildInfo.yaml
    │   ├── bytecode_modules
    │   │   └── *.mv
    │   ├── source_maps
    │   │   └── *.mvsm
    │   ├── bytecode_scripts
    │   │   └── *.mv
    │   ├── abis
    │   │   ├── *.abi
    │   │   └── &lt;module_name&gt;/*.abi
    │   └── sources
    │       └── *.move
    ...
    └── &lt;dep_pkg_name&gt;
        ├── BuildInfo.yaml
        ...
        └── sources
</code></pre>
<p>See the <code>move-package</code> crate for more information on these data structures and
how to use the Move package system as a Rust library.</p>
<p>有关这些数据结构以及如何将 Move 包系统用作 Rust 库的更多信息，请参阅 move-package crate。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Unit testing for Move adds three new annotations to the Move source language:</p>
<ul>
<li><code>#[test]</code></li>
<li><code>#[test_only]</code>, and</li>
<li><code>#[expected_failure]</code>.</li>
</ul>
<p>They respectively mark a function as a test, mark a module or module member (<code>use</code>, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as <code>#[test_only]</code> or <code>#[test]</code>, it will not be included in the compiled bytecode unless it is compiled for testing.</p>
<h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<p>Move 的单元测试为 Move 源语言添加了三个新注释：</p>
<ul>
<li>#[test]</li>
<li>#[test_only]，和</li>
<li>#[expected_failure]。</li>
</ul>
<p>它们分别将函数标记为测试，将模块或模块成员（使用、函数或结构）标记为仅用于测试的代码，并标记预期测试将失败。这些注释可以放置在具有任何可见性的函数上。每当一个模块或模块成员被注释为 <code>#[test_only]</code> 或 <code>#[test]</code> 时，它不会包含在编译的字节码中，除非它被编译用于测试。</p>
<h2 id="testing-annotations-their-meaning-and-usage"><a class="header" href="#testing-annotations-their-meaning-and-usage">Testing Annotations: Their Meaning and Usage</a></h2>
<p>Both the <code>#[test]</code> and <code>#[expected_failure]</code> annotations can be used either with or without arguments.</p>
<p>Without arguments, the <code>#[test]</code> annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.</p>
<h2 id="测试注释它们的含义和用法"><a class="header" href="#测试注释它们的含义和用法">测试注释：它们的含义和用法</a></h2>
<p><code>#[test]</code> 和 <code>#[expected_failure]</code> 注释都可以带或不带参数使用。</p>
<p>没有参数，#[test] 注释只能放在没有参数的函数上。此注释只是将此函数标记为要由单元测试工具运行的测试。</p>
<pre><code>#[test] // OK
fun this_is_a_test() { ... }

#[test] // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: signer) { ... }
</code></pre>
<p>A test can also be annotated as an <code>#[expected_failure]</code>. This annotation marks that the test should is expected to raise an error. You can ensure that a test is aborting with a specific abort code by annotating it with <code>#[expected_failure(abort_code = &lt;code&gt;)]</code>, if it then fails with a different abort code or with a non-abort error the test will fail. Only functions that have the <code>#[test]</code> annotation can also be annotated as an #<code>[expected_failure]</code>.</p>
<p>测试也可以注释为 <code>#[expected_failure]</code>。此注释标志着测试应该会引发错误。您可以通过使用 <code>#[expected_failure(abort_code = code)]</code> 对其进行注释来确保测试使用特定的中止代码中止，如果它随后因不同的中止代码或非中止错误而失败，则测试将失败。只有具有 <code>#[test]</code> 注释的函数也可以注释为 <code>#[expected_failure]</code>。</p>
<pre><code>#[test]
#[expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test]
#[expected_failure]
public fun test_will_error_and_pass() { 1/0; }

#[test]
#[expected_failure(abort_code = 0)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
</code></pre>
<p>With arguments, a test annotation takes the form <code>#[test(&lt;param_name_1&gt; = &lt;address&gt;, ..., &lt;param_name_n&gt; = &lt;address&gt;)]</code>. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters &lt;<code>param_name_1&gt;, ..., &lt;param_name_n&gt;</code>, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.</p>
<p>Only parameters with a type of <code>signer</code> are supported as test parameters. If a non-<code>signer</code> parameter is supplied, the test will result in an error when run.</p>
<p>带有参数的测试注解采用 <code>#[test( param_name_1 = address , ..., param_name_n = address )]</code> 的形式。如果以这种方式注释函数，则函数的参数必须是参数 param_name_1 , ..., param_name_n 的排列，即这些参数在函数中出现的顺序和它们在测试注释中的顺序不必须相同，但它们必须能够通过名称相互匹配。</p>
<p>仅支持具有签名者类型的参数作为测试参数。如果提供了非签名者参数，则测试将在运行时导致错误。</p>
<pre><code>#[test(arg = @0xC0FFEE)] // OK
fun this_is_correct_now(arg: signer) { ... }

#[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match
fun this_is_incorrect(arg: signer) { ... }

#[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument
fun this_works(a: signer, b: signer) { ... }

// somewhere a named address is declared
#[test_only] // test-only named addresses are supported
address TEST_NAMED_ADDR = @0x1;
...
#[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!
fun this_is_correct_now(arg: signer) { ... }
</code></pre>
<p>An expected failure annotation can also take the form <code>#[expected_failure(abort_code = &lt;u64&gt;)]</code>. If a test function is annotated in such a way, the test must abort with an abort code equal to <code>&lt;u64&gt;</code>. Any other failure or abort code will result in a test failure.</p>
<p>预期的失败注释也可以采用 #[expected_failure(abort_code = u64)] 的形式。如果以这种方式注释测试函数，则必须使用等于 u64 的中止代码中止测试。任何其他失败或中止代码都将导致测试失败。</p>
<pre><code>#[test, expected_failure(abort_code = 1)] // This test will fail
fun this_test_should_abort_and_fail() { abort 0 }

#[test]
#[expected_failure(abort_code = 0)] // This test will pass
fun this_test_should_abort_and_pass_too() { abort 0 }
</code></pre>
<p>A module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test <code>use</code>s of a <code>#[test_only]</code> module will raise an error during compilation.</p>
<p>一个模块及其任何成员都可以声明为仅测试。在这种情况下，只有在测试模式下编译时，该项目才会包含在编译后的 Move 字节码中。此外，在测试模式之外编译时，#[test_only] 模块的任何非测试使用都会在编译期间引发错误。</p>
<pre><code>#[test_only] // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only attributes can be attached to named addresses
address ADDR = @0x1;

#[test_only] // .. to uses
use 0x1::some_other_module;

#[test_only] // .. to structs
struct SomeStruct { ... }

#[test_only] // .. and functions. Can only be called from test code, but not a test
fun test_only_function(...) { ... }
</code></pre>
<h2 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running Unit Tests</a></h2>
<p>Unit tests for a Move package can be run with the <a href="./packages.html"><code>move test</code>
command</a>.</p>
<p>When running tests, every test will either <code>PASS</code>, <code>FAIL</code>, or <code>TIMEOUT</code>. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.</p>
<p>A test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 5000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see <code>OPTIONS</code> below).</p>
<p>There are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the the help flag:</p>
<h2 id="运行单元测试"><a class="header" href="#运行单元测试">运行单元测试</a></h2>
<p>可以使用 move test 命令运行 Move 包的单元测试。</p>
<p>运行测试时，每个测试都将通过、失败或超时。如果测试用例失败，将尽可能报告失败的位置以及导致失败的函数名称。您可以在下面看到一个示例。</p>
<p>如果测试超过任何单个测试可以执行的最大指令数，则测试将被标记为超时。可以使用以下选项更改此界限，其默认值设置为 5000 条指令。此外，虽然测试的结果始终是确定性的，但默认情况下测试是并行运行的，因此测试运行中测试结果的顺序是不确定的，除非仅使用一个线程运行（请参阅下面的选项）。</p>
<p>还有许多选项可以传递给单元测试二进制文件以微调测试并帮助调试失败的测试。这些可以使用帮助标志找到：</p>
<pre><code>$ move -h
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>A simple module using some of the unit testing features is shown in the following example:</p>
<p>First create an empty package and change directory into it:</p>
<h2 id="例子-4"><a class="header" href="#例子-4">例子</a></h2>
<p>以下示例显示了使用一些单元测试功能的简单模块：</p>
<p>首先创建一个空包并将目录更改为它：</p>
<pre><code>$ move new TestExample; cd TestExample
</code></pre>
<p>Next add the following to the <code>Move.toml</code>:</p>
<p>接下来将以下内容添加到 Move.toml：</p>
<pre><code>[dependencies]
MoveStdlib = { git = &quot;https://github.com/diem/diem.git&quot;, subdir=&quot;language/move-stdlib&quot;, rev = &quot;56ab033cc403b489e891424a629e76f643d4fb6b&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
</code></pre>
<p>Next add the following module under the <code>sources</code> directory:</p>
<p>接下来在源目录下添加以下模块：</p>
<pre><code>// filename: sources/my_module.move
module 0x1::my_module {

    struct MyCoin has key { value: u64 }

    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {
        assert!(coin.value &gt; 0, 0);
        coin
    }

    public fun has_coin(addr: address): bool {
        exists&lt;MyCoin&gt;(addr)
    }

    #[test]
    fun make_sure_non_zero_coin_passes() {
        let coin = MyCoin { value: 1 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test]
    // Or #[expected_failure] if we don't care about the abort code
    #[expected_failure(abort_code = 0)]
    fun make_sure_zero_coin_fails() {
        let coin = MyCoin { value: 0 };
        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
    }

    #[test_only] // test only helper function
    fun publish_coin(account: &amp;signer) {
        move_to(account, MyCoin { value: 1 })
    }

    #[test(a = @0x1, b = @0x2)]
    fun test_has_coin(a: signer, b: signer) {
        publish_coin(&amp;a);
        publish_coin(&amp;b);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
        assert!(!has_coin(@0x3), 1);
    }
}
</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>You can then run these tests with the <code>move test</code> command:</p>
<h3 id="运行测试"><a class="header" href="#运行测试">运行测试</a></h3>
<p>然后，您可以使用 move test 命令运行这些测试：</p>
<pre><code>$ move test
BUILDING MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h3 id="using-test-flags"><a class="header" href="#using-test-flags">Using Test Flags</a></h3>
<h4 id="-f-str-or---filter-str"><a class="header" href="#-f-str-or---filter-str"><code>-f &lt;str&gt;</code> or <code>--filter &lt;str&gt;</code></a></h4>
<p>This will only run tests whose fully qualified name contains <code>&lt;str&gt;</code>. For example if we wanted to only run tests with <code>&quot;zero_coin&quot;</code> in their name:</p>
<h3 id="使用测试标志"><a class="header" href="#使用测试标志">使用测试标志</a></h3>
<h4 id="-f-str-或---filter-str"><a class="header" href="#-f-str-或---filter-str"><code>-f &lt;str&gt;</code> 或 <code>--filter &lt;str&gt;</code></a></h4>
<p>这只会运行完全限定名称包含 str 的测试。例如，如果我们只想运行名称中带有“zero_coin”的测试：</p>
<pre><code>$ move test -f zero_coin
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
Test result: OK. Total tests: 2; passed: 2; failed: 0
</code></pre>
<h4 id="-i-bound-or---instructions-bound"><a class="header" href="#-i-bound-or---instructions-bound"><code>-i &lt;bound&gt;</code> or <code>--instructions &lt;bound&gt;</code></a></h4>
<p>This bounds the number of instructions that can be executed for any one test to <code>&lt;bound&gt;</code>:</p>
<h4 id="-i-bound-或---instructions-bound"><a class="header" href="#-i-bound-或---instructions-bound"><code>-i &lt;bound&gt;</code> 或 <code>--instructions &lt;bound&gt;</code></a></h4>
<p>这将任何一个测试可以执行的指令数限制为 bound ：</p>
<pre><code>$ move test -i 0
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ TIMEOUT ] 0x1::my_module::make_sure_non_zero_coin_passes
[ TIMEOUT ] 0x1::my_module::make_sure_zero_coin_fails
[ TIMEOUT ] 0x1::my_module::test_has_coin

Test failures:

Failures in 0x1::my_module:

┌── make_sure_non_zero_coin_passes ──────
│ Test timed out
└──────────────────


┌── make_sure_zero_coin_fails ──────
│ Test timed out
└──────────────────


┌── test_has_coin ──────
│ Test timed out
└──────────────────

Test result: FAILED. Total tests: 3; passed: 0; failed: 3
</code></pre>
<h4 id="-s-or---statistics"><a class="header" href="#-s-or---statistics"><code>-s</code> or <code>--statistics</code></a></h4>
<p>With these flags you can gather statistics about the tests run and report the runtime and instructions executed for each test. For example, if we wanted to see the statistics for the tests in the example above:</p>
<h4 id="-s-或---statistics"><a class="header" href="#-s-或---statistics"><code>-s</code> 或 <code>--statistics</code></a></h4>
<p>使用这些标志，您可以收集有关测试运行的统计信息，并报告每个测试的运行时间和执行的指令。例如，如果我们想查看上例中测试的统计信息：</p>
<pre><code>$ move test -s
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin

Test Statistics:

┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐
│                   Test Name                    │    Time    │   Instructions Executed   │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_non_zero_coin_passes │   0.009    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::make_sure_zero_coin_fails      │   0.008    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x1::my_module::test_has_coin                  │   0.008    │             1             │
└────────────────────────────────────────────────┴────────────┴───────────────────────────┘

Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h4 id="-g-or---state-on-error"><a class="header" href="#-g-or---state-on-error"><code>-g</code> or <code>--state-on-error</code></a></h4>
<p>These flags will print the global state for any test failures. e.g., if we added the following (failing) test to the <code>my_module</code> example:</p>
<h4 id="-g-或---state-on-error"><a class="header" href="#-g-或---state-on-error"><code>-g</code> 或 <code>--state-on-error</code></a></h4>
<p>这些标志将打印任何测试失败的全局状态。例如，如果我们将以下（失败）测试添加到 my_module 示例中：</p>
<pre><code>module 0x1::my_module {
    ...
    #[test(a = @0x1)]
    fun test_has_coin_bad(a: signer) {
        publish_coin(&amp;a);
        assert!(has_coin(@0x1), 0);
        assert!(has_coin(@0x2), 1);
    }
}
</code></pre>
<p>we would get get the following output when running the tests:</p>
<p>运行测试时我们会得到以下输出：</p>
<pre><code>$ move test -g
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
[ FAIL    ] 0x1::my_module::test_has_coin_bad

Test failures:

Failures in 0x1::my_module:

┌── test_has_coin_bad ──────
│ error[E11001]: test failure
│    ┌─ /home/tzakian/TestExample/sources/my_module.move:47:10
│    │
│ 44 │      fun test_has_coin_bad(a: signer) {
│    │          ----------------- In this function in 0x1::my_module
│    ·
│ 47 │          assert!(has_coin(@0x2), 1);
│    │          ^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 1 here
│
│
│ ────── Storage state at point of failure ──────
│ 0x1:
│       =&gt; key 0x1::my_module::MyCoin {
│           value: 1
│       }
│
└──────────────────

Test result: FAILED. Total tests: 4; passed: 3; failed: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局存储--结构"><a class="header" href="#全局存储--结构">全局存储 —— 结构</a></h1>
<p>Move 程序的目的是<a href="./global-storage-operators.html">读取和写入</a>树形的持久全局存储。程序不能访问文件系统、网络或任何此树以外的数据。</p>
<p>在伪代码中，全局存储看起来像：</p>
<pre><code class="language-move">struct GlobalStorage {
  resources: Map&lt;(address, ResourceType), ResourceValue&gt;
  modules: Map&lt;(address, ModuleName), ModuleBytecode&gt;
}
</code></pre>
<p>从结构上讲，全局存储是一个<a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">森林（forest）</a>，这个森林由以账户<a href="./address.html">地址（<code>address</code>）</a>为根的树组成。每个地址可以存储<a href="./structs-and-resources.html">资源（resource）</a>数据和<a href="./modules-and-scripts.html">模块（module）</a>代码。如上面的伪代码所示，每个地址（<code>address</code>）最多可以存储一个给定类型的资源值，最多可以存储一个给定名称的模块。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-storage---operators"><a class="header" href="#global-storage---operators">Global Storage - Operators</a></h1>
<p>Move programs can create, delete, and update <a href="./structs-and-resources.html">resources</a> in global storage using the following five instructions:</p>
<h1 id="全球存储---操作符"><a class="header" href="#全球存储---操作符">全球存储 - 操作符</a></h1>
<p>移动程序可以使用以下五个指令在全局存储中创建、删除和更新资源：</p>
<table><thead><tr><th>Operation</th><th>Description</th><th>Aborts?</th></tr></thead><tbody>
<tr><td><code>move_to&lt;T&gt;(&amp;signer,T)</code></td><td>Publish <code>T</code> under <code>signer.address</code></td><td>If <code>signer.address</code> already holds a <code>T</code></td></tr>
<tr><td><code>move_from&lt;T&gt;(address): T</code></td><td>Remove <code>T</code> from <code>address</code> and return it</td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global_mut&lt;T&gt;(address): &amp;mut T</code></td><td>Return a mutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>borrow_global&lt;T&gt;(address): &amp;T</code></td><td>Return an immutable reference to the <code>T</code> stored under <code>address</code></td><td>If <code>address</code> does not hold a <code>T</code></td></tr>
<tr><td><code>exists&lt;T&gt;(address): bool</code></td><td>Return <code>true</code> if a <code>T</code> is stored under <code>address</code></td><td>Never</td></tr>
</tbody></table>
<p>Each of these instructions is parameterized by a type <code>T</code> with the <a href="./abilities.html"><code>key</code> ability</a>. However, each type <code>T</code> <em>must be declared in the current module</em>. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an <a href="./address.html"><code>address</code></a> or <a href="./signer.html"><code>&amp;signer</code></a> representing the account address where the resource of type <code>T</code> is stored.</p>
<p>这些指令中的每一个都由具有关键能力的类型 T 参数化。但是，每个类型 T 都必须在当前模块中声明。这确保了资源只能通过其定义模块公开的 API 进行操作。这些指令还采用地址或 &amp;signer 表示存储类型 T 资源的帐户地址。</p>
<h2 id="references-to-resources"><a class="header" href="#references-to-resources">References to resources</a></h2>
<p>References to global resources returned by <code>borrow_global</code> or <code>borrow_global_mut</code> mostly behave like references to local storage: they can be extended, read, and written using ordinary <a href="./references.html">reference operators</a> and passed as arguments to other function. However, there is one important difference between local and global references: <strong>a function cannot return a reference that points into global storage</strong>. For example, these two functions will each fail to compile:</p>
<h2 id="对资源的引用"><a class="header" href="#对资源的引用">对资源的引用</a></h2>
<p>borrow_global 或 borrow_global_mut 返回的对全局资源的引用主要表现为对本地存储的引用：它们可以使用普通的引用运算符进行扩展、读取和写入，并作为参数传递给其他函数。但是，本地引用和全局引用之间有一个重要区别：函数不能返回指向全局存储的引用。例如，这两个函数都将无法编译：</p>
<pre><code class="language-move">struct R has key { f: u64 }
// will not compile
fun ret_direct_resource_ref_bad(a: address): &amp;R {
    borrow_global&lt;R&gt;(a) // error!
}
// also will not compile
fun ret_resource_field_ref_bad(a: address): &amp;u64 {
    &amp;borrow_global&lt;R&gt;(a).f // error!
}
</code></pre>
<p>Move must enforce this restriction to guarantee absence of dangling references to global storage. <a href="global-storage-operators.html#reference-safety-for-global-resources">This</a> section contains much more detail for the interested reader.</p>
<p>Move 必须强制执行此限制以保证不存在对全局存储的悬空引用。本节为感兴趣的读者提供了更多详细信息。</p>
<h2 id="global-storage-operators-with-generics"><a class="header" href="#global-storage-operators-with-generics">Global storage operators with generics</a></h2>
<p>Global storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:</p>
<h2 id="具有泛型的全局存储运算符"><a class="header" href="#具有泛型的全局存储运算符">具有泛型的全局存储运算符</a></h2>
<p>全局存储操作可以应用于具有实例化和未实例化的泛型类型参数的泛型资源：</p>
<pre><code class="language-move">struct Container&lt;T&gt; has key { t: T }

// Publish a Container storing a type T of the caller's choosing
fun publish_generic_container&lt;T&gt;(account: &amp;signer, t: T) {
    move_to&lt;Container&lt;T&gt;&gt;(account, Container { t })
}

/// Publish a container storing a u64
fun publish_instantiated_generic_container(account: &amp;signer, t: u64) {
    move_to&lt;Container&lt;u64&gt;&gt;(account, Container { t })
}
</code></pre>
<p>The ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as <em>storage polymorphism</em>. For more on the design patterns enabled by this feature, see <a href="./generics.html">Move generics</a>.</p>
<p>通过在运行时选择的类型参数对全局存储进行索引的能力是一种强大的移动功能，称为存储多态性。有关此功能启用的设计模式的更多信息，请参阅移动泛型。</p>
<h2 id="example-counter"><a class="header" href="#example-counter">Example: <code>Counter</code></a></h2>
<p>The simple <code>Counter</code> module below exercises each of the five global storage operators. The API exposed by this module allows:</p>
<ul>
<li>Anyone to publish a <code>Counter</code> resource under their account</li>
<li>Anyone to check if a <code>Counter</code> exists under any address</li>
<li>Anyone to read or increment the value of a <code>Counter</code> resource under any address</li>
<li>An account that stores a <code>Counter</code> resource to reset it to zero</li>
<li>An account that stores a <code>Counter</code> resource to remove and delete it</li>
</ul>
<h2 id="示例计数器"><a class="header" href="#示例计数器">示例：计数器</a></h2>
<p>下面的简单 Counter 模块练习了五个全局存储运算符中的每一个。该模块公开的 API 允许：</p>
<ul>
<li>任何人都可以在其帐户下发布 Counter 资源</li>
<li>任何人都可以检查任何地址下是否存在计数器</li>
<li>任何人都可以读取或增加任何地址下的 Counter 资源的值</li>
<li>存储计数器资源以将其重置为零的帐户</li>
<li>存储 Counter 资源以移除和删除它的帐户</li>
</ul>
<pre><code class="language-move">address 0x42 {
module counter {
    use std::signer;

    /// Resource that wraps an integer counter
    struct Counter has key { i: u64 }

    /// Publish a `Counter` resource with value `i` under the given `account`
    public fun publish(account: &amp;signer, i: u64) {
      // &quot;Pack&quot; (create) a Counter resource. This is a privileged operation that
      // can only be done inside the module that declares the `Counter` resource
      move_to(account, Counter { i })
    }

    /// Read the value in the `Counter` resource stored at `addr`
    public fun get_count(addr: address): u64 acquires Counter {
        borrow_global&lt;Counter&gt;(addr).i
    }

    /// Increment the value of `addr`'s `Counter` resource
    public fun increment(addr: address) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(addr).i;
        *c_ref = *c_ref + 1
    }

    /// Reset the value of `account`'s `Counter` to 0
    public fun reset(account: &amp;signer) acquires Counter {
        let c_ref = &amp;mut borrow_global_mut&lt;Counter&gt;(signer::address_of(account)).i;
        *c_ref = 0
    }

    /// Delete the `Counter` resource under `account` and return its value
    public fun delete(account: &amp;signer): u64 acquires Counter {
        // remove the Counter resource
        let c = move_from&lt;Counter&gt;(signer::address_of(account));
        // &quot;Unpack&quot; the `Counter` resource into its fields. This is a
        // privileged operation that can only be done inside the module
        // that declares the `Counter` resource
        let Counter { i } = c;
        i
    }

    /// Return `true` if `addr` contains a `Counter` resource
    public fun exists(addr: address): bool {
        exists&lt;Counter&gt;(addr)
    }
}
}
</code></pre>
<h2 id="annotating-functions-with-acquires"><a class="header" href="#annotating-functions-with-acquires">Annotating functions with <code>acquires</code></a></h2>
<p>In the <code>counter</code> example, you might have noticed that the <code>get_count</code>, <code>increment</code>, <code>reset</code>, and <code>delete</code> functions are annotated with <code>acquires Counter</code>. A Move function <code>m::f</code> must be annotated with <code>acquires T</code> if and only if:</p>
<ul>
<li>The body of <code>m::f</code> contains a <code>move_from&lt;T&gt;</code>, <code>borrow_global_mut&lt;T&gt;</code>, or <code>borrow_global&lt;T&gt;</code> instruction, or</li>
<li>The body of <code>m::f</code> invokes a function <code>m::g</code> declared in the same module that is annotated with <code>acquires</code></li>
</ul>
<p>For example, the following function inside <code>Counter</code> would need an <code>acquires</code> annotation:</p>
<h2 id="使用获取注释函数"><a class="header" href="#使用获取注释函数">使用获取注释函数</a></h2>
<p>在 counter 示例中，您可能已经注意到 get_count、increment、reset 和 delete 函数都使用 acquire Counter 进行注释。移动函数 m::f 必须用获取 T 注释当且仅当：</p>
<ul>
<li>m::f 的主体包含 move_from T 、 borrow_global_mut T 或 borrow_global T 指令，或</li>
<li>m::f 的主体调用在同一个模块中声明的函数 m::g
例如，Counter 中的以下函数需要一个获取注解：</li>
</ul>
<pre><code class="language-move">// Needs `acquires` because `increment` is annotated with `acquires`
fun call_increment(addr: address): u64 acquires Counter {
    counter::increment(addr)
}
</code></pre>
<p>However, the same function <em>outside</em> <code>Counter</code> would not need an annotation:</p>
<p>但是，Counter 之外的相同函数不需要注释：</p>
<pre><code class="language-move">address 0x43 {
module m {
   use 0x42::counter;

   // Ok. Only need annotation when resource acquired by callee is declared
   // in the same module
   fun call_increment(addr: address): u64 {
       counter::increment(addr)
   }
}
}
</code></pre>
<p>If a function touches multiple resources, it needs multiple <code>acquires</code>:</p>
<p>如果一个函数涉及多个资源，它需要多次获取：</p>
<pre><code class="language-move=">address 0x42 {
module two_resources {
    struct R1 has key { f: u64 }
    struct R2 has key { g: u64 }

    fun double_acquires(a: address): u64 acquires R1, R2 {
        borrow_global&lt;R1&gt;(a).f + borrow_global&lt;R2&gt;.g
    }
}
}
</code></pre>
<p>The <code>acquires</code> annotation does not take generic type parameters into account:</p>
<p>获取注解不考虑泛型类型参数：</p>
<pre><code class="language-move=">address 0x42 {
module m {
    struct R&lt;T&gt; has key { t: T }

    // `acquires R`, not `acquires R&lt;T&gt;`
    fun acquire_generic_resource&lt;T: store&gt;(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;T&gt;&gt;(a);
    }

    // `acquires R`, not `acquires R&lt;u64&gt;
    fun acquire_instantiated_generic_resource(a: addr) acquires R {
        let _ = borrow_global&lt;R&lt;u64&gt;&gt;(a);
    }
}
}
</code></pre>
<p>Finally: redundant <code>acquires</code> are not allowed. Adding this function inside <code>Counter</code> will result in a compilation error:</p>
<p>最后：不允许冗余获取。在 Counter 中添加这个函数会导致编译错误：</p>
<pre><code class="language-move">// This code will not compile because the body of the function does not use a global
// storage instruction or invoke a function with `acquires`
fun redundant_acquires_bad() acquires Counter {}
</code></pre>
<p>For more information on <code>acquires</code>, see <a href="./functions.html">Move functions</a>.</p>
<p>有关获取的更多信息，请参阅移动函数。</p>
<h2 id="reference-safety-for-global-resources"><a class="header" href="#reference-safety-for-global-resources">Reference Safety For Global Resources</a></h2>
<p>Move prohibits returning global references and requires the <code>acquires</code> annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no <code>null</code> or <code>nil</code> dereferences) for all <a href="./references.html">reference</a> types.</p>
<p>This example illustrates how the Move type system uses <code>acquires</code> to prevent a dangling reference:</p>
<h2 id="全局资源的引用安全"><a class="header" href="#全局资源的引用安全">全局资源的引用安全</a></h2>
<p>Move 禁止返回全局引用，并要求获取注解以防止悬空引用。这允许 Move 兑现其对所有引用类型的静态引用安全的承诺（即，没有悬空引用，没有 null 或 nil 取消引用）。</p>
<p>此示例说明了 Move 类型系统如何使用获取来防止悬空引用：</p>
<pre><code class="language-move=">address 0x42 {
module dangling {
    struct T has key { f: u64 }

    fun borrow_then_remove_bad(a: address) acquires T {
        let t_ref: &amp;mut T = borrow_global_mut&lt;T&gt;(a);
        let t = remove_t(a); // type system complains here
        // t_ref now dangling!
        let uh_oh = *&amp;t_ref.f
    }

    fun remove_t(a: address): T acquires T {
        move_from&lt;T&gt;(a)
    }

}
}
</code></pre>
<p>In this code, line 6 acquires a reference to the <code>T</code> stored at address <code>a</code> in global storage. The callee <code>remove_t</code> then removes the value, which makes <code>t_ref</code> a dangling reference.</p>
<p>Fortunately, this cannot happen because the type system will reject this program. The <code>acquires</code> annotation on <code>remove_t</code> lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of <code>remove_t</code> separately!</p>
<p>The restriction on returning global references prevents a similar, but even more insidious problem:</p>
<p>在此代码中，第 6 行获取对存储在全局存储中地址 a 处的 T 的引用。被调用者 remove_t 然后删除该值，这使 t_ref 成为悬空引用。</p>
<p>幸运的是，这不可能发生，因为类型系统会拒绝这个程序。 remove_t 上的 acquires 注释让类型系统知道第 7 行是危险的，而无需单独重新检查或反省 remove_t 的主体！</p>
<p>对返回全局引用的限制防止了类似但更隐蔽的问题：</p>
<pre><code class="language-move=">address 0x42 {
module m1 {
    struct T has key {}

    public fun ret_t_ref(a: address): &amp;T acquires T {
        borrow_global&lt;T&gt;(a) // error! type system complains here
    }

    public fun remove_t(a: address) acquires T {
        let T {} = move_from&lt;T&gt;(a);
    }
}

module m2 {
    fun borrow_then_remove_bad(a: address) {
        let t_ref = m1::ret_t_ref(a);
        let t = m1::remove_t(a); // t_ref now dangling!
    }
}
}
</code></pre>
<p>Line 16 acquires a reference to a global resource <code>m1::T</code>, then line 17 removes that same resource, which makes <code>t_ref</code> dangle. In this case, <code>acquires</code> annotations do not help us because the <code>borrow_then_remove_bad</code> function is outside of the <code>m1</code> module that declares <code>T</code> (recall that <code>acquires</code> annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.</p>
<p>Fancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between expressivity, annotation burden, and type system complexity.</p>
<p>第 16 行获取对全局资源 m1::T 的引用，然后第 17 行删除相同的资源，这使得 t_ref 悬空。在这种情况下，获取注解对我们没有帮助，因为 borrow_then_remove_bad 函数位于声明 T 的 m1 模块之外（回想一下，获取注解只能用于在当前模块中声明的资源）。相反，类型系统通过阻止在第 6 行返回全局引用来避免这个问题。</p>
<p>在不牺牲引用安全的情况下允许返回全局引用的更高级的类型系统是可能的，我们可能会在 Move 的未来迭代中考虑它们。我们选择了当前的设计，因为它在表现力、注释负担和类型系统复杂性之间取得了很好的平衡。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>The Move standard library exposes interfaces that implement the following functionality:</p>
<ul>
<li><a href="standard-library.html#vector">Basic operations on vectors</a>.</li>
<li><a href="standard-library.html#option">Option types and operations on<code>Option</code> types</a>.</li>
<li><a href="standard-library.html#errors">A common error encoding code interface for abort codes</a>.</li>
<li><a href="standard-library.html#fixed_point32">32-bit precision fixed-point numbers</a>.</li>
</ul>
<h1 id="标准库"><a class="header" href="#标准库">标准库</a></h1>
<p>Move 标准库公开了实现以下功能的接口：</p>
<ul>
<li>向量的基本操作。</li>
<li>选项类型和选项类型的操作。</li>
<li>中止代码的常见错误编码代码接口。</li>
<li>32 位精度定点数。</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">vector</a></h2>
<p>The <code>vector</code> module defines a number of operations over the primitive
<a href="./vector.html"><code>vector</code></a> type. The module is published under the
named address <code>Std</code> and consists of a number of native functions, as
well as functions defined in Move. The API for this module is as follows.</p>
<h2 id="向量-1"><a class="header" href="#向量-1">向量</a></h2>
<p>vector 模块定义了对原始向量类型的许多操作。该模块在命名地址 Std 下发布，由许多本机函数以及 Move 中定义的函数组成。该模块的 API 如下。</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<h3 id="函数-1"><a class="header" href="#函数-1">函数</a></h3>
<hr />
<p>Create an empty <a href="./vector.html"><code>vector</code></a>.
The <code>Element</code> type can be both a <code>resource</code> or <code>copyable</code> type.</p>
<p>创建一个空向量。 Element 类型既可以是资源类型，也可以是可复制类型。</p>
<pre><code class="language-move">    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a vector of length <code>1</code> containing the passed in <code>element</code>.</p>
<p>创建一个包含传入元素的长度为 1 的向量。</p>
<pre><code class="language-move">    public fun singleton&lt;Element&gt;(e: Element): vector&lt;Element&gt;;
</code></pre>
<hr />
<p>Destroy (deallocate) the vector <code>v</code>. Will abort if <code>v</code> is non-empty.
<em>Note</em>: The emptiness restriction is due to the fact that <code>Element</code> can be a
resource type, and destruction of a non-empty vector would violate
<a href="./structs-and-resources.html">resource conservation</a>.</p>
<p>销毁（解除分配）向量 v。如果 v 不为空，将中止。注意：空性限制是由于 Element 可以是资源类型，销毁非空向量会违反资源守恒。</p>
<pre><code class="language-move">    native public fun destroy_empty&lt;Element&gt;(v: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Acquire an <a href="./references.html">immutable reference</a> to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>获取对向量 v 的第 i 个元素的不可变引用。如果索引 i 超出向量 v 的范围，将中止。</p>
<pre><code class="language-move">    native public fun borrow&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, i: u64): &amp;Element;
</code></pre>
<hr />
<p>Acquire a <a href="./references.html">mutable reference</a>
to the <code>i</code>th element of the vector <code>v</code>.  Will abort if
the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>获取对向量 v 的第 i 个元素的可变引用。如果索引 i 超出向量 v 的范围，将中止。</p>
<pre><code class="language-move">    native public fun borrow_mut&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): &amp;mut Element;
</code></pre>
<hr />
<p>Empty and destroy the <code>other</code> vector, and push each of the elements in
the <code>other</code> vector onto the <code>lhs</code> vector in the same order as they occurred in <code>other</code>.</p>
<p>清空并销毁另一个向量，并将另一个向量中的每个元素以与它们在其他向量中出现的顺序相同的顺序推送到 lhs 向量上。</p>
<pre><code class="language-move">    public fun append&lt;Element&gt;(lhs: &amp;mut vector&lt;Element&gt;, other: vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Push an element <code>e</code> of type <code>Element</code> onto the end of the vector <code>v</code>. May
trigger a resizing of the underlying vector's memory.</p>
<p>将 Element 类型的元素 e 推到向量 v 的末尾。可能会触发底层向量内存的大小调整。</p>
<pre><code class="language-move">    native public fun push_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Pop an element from the end of the vector <code>v</code> in-place and return the owned
value. Will abort if <code>v</code> is empty.</p>
<p>从向量 v 的末尾就地弹出一个元素并返回拥有的值。如果 v 为空，将中止。</p>
<pre><code class="language-move">    native public fun pop_back&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Remove the element at index <code>i</code> in the vector <code>v</code> and return the owned value
that was previously stored at <code>i</code> in <code>v</code>. All elements occurring at indices
greater than <code>i</code> will be shifted down by 1. Will abort if <code>i</code> is out of bounds
for <code>v</code>.</p>
<p>删除向量 v 中索引 i 处的元素，并返回先前存储在 v 中 i 处的拥有值。所有出现在索引处大于 i 的元素将向下移动 1。如果 i 超出 v 的范围，将中止。</p>
<pre><code class="language-move">    public fun remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop
this element off of the back of the vector and return the owned value that
was previously stored at index <code>i</code>.
This operation is O(1), but does not preserve ordering of elements in the vector.
Aborts if the index <code>i</code> is out of bounds for the vector <code>v</code>.</p>
<p>将向量 v 的第 i 个元素与最后一个元素交换，然后将该元素从向量的背面弹出，并返回之前存储在索引 i 处的拥有值。此操作为 O(1)，但不保留向量中元素的顺序。如果索引 i 超出向量 v 的范围，则中止。</p>
<pre><code class="language-move">    public fun swap_remove&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): Element;
</code></pre>
<hr />
<p>Swap the elements at the <code>i</code>'th and <code>j</code>'th indices in the vector <code>v</code>. Will
abort if either of <code>i</code> or <code>j</code> are out of bounds for <code>v</code>.</p>
<p>交换向量 v 中第 i 个和第 j 个索引处的元素。如果 i 或 j 中的任何一个超出 v 的范围，则将中止。</p>
<pre><code class="language-move">    native public fun swap&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64, j: u64);
</code></pre>
<hr />
<p>Reverse the order of the elements in the vector <code>v</code> in-place.</p>
<p>就地反转向量 v 中元素的顺序。</p>
<pre><code class="language-move">    public fun reverse&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;);
</code></pre>
<hr />
<p>Return the index of the first occurrence of an element in <code>v</code> that is
equal to <code>e</code>. Returns <code>(true, index)</code> if such an element was found, and
<code>(false, 0)</code> otherwise.</p>
<p>返回 v 中等于 e 的元素第一次出现的索引。如果找到这样的元素，则返回 (true, index)，否则返回 (false, 0)。</p>
<pre><code class="language-move">    public fun index_of&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): (bool, u64);
</code></pre>
<hr />
<p>Return if an element equal to <code>e</code> exists in the vector <code>v</code>.</p>
<p>如果向量 v 中存在等于 e 的元素，则返回。</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, e: &amp;Element): bool;
</code></pre>
<hr />
<p>Return the length of a <code>vector</code>.</p>
<p>返回向量的长度。</p>
<pre><code class="language-move">    native public fun length&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): u64;
</code></pre>
<hr />
<p>Return whether the vector <code>v</code> is empty.</p>
<p>返回向量 v 是否为空。</p>
<pre><code class="language-move">    public fun is_empty&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): bool;
</code></pre>
<hr />
<h2 id="option"><a class="header" href="#option">option</a></h2>
<p>The <code>option</code> module defines a generic option type <code>Option&lt;T&gt;</code> that represents a
value of type <code>T</code> that may, or may not, be present. It is published under the named address <code>Std</code>.</p>
<p>The Move option type is internally represented as a singleton vector, and may
contain a value of <code>resource</code> or <code>copyable</code> kind.  If you are familiar with option
types in other languages, the Move <code>Option</code> behaves similarly to those with a
couple notable exceptions since the option can contain a value of kind <code>resource</code>.
Particularly, certain operations such as <code>get_with_default</code> and
<code>destroy_with_default</code> require that the element type <code>T</code> be of <code>copyable</code> kind.</p>
<p>The API for the <code>option</code> module is as as follows</p>
<h2 id="选项"><a class="header" href="#选项">选项</a></h2>
<p>选项模块定义了一个通用选项类型 Option T，它代表一个类型 T 的值，该值可能存在，也可能不存在。它以命名地址 Std 发布。</p>
<p>Move 选项类型在内部表示为单例向量，并且可能包含资源或可复制种类的值。如果您熟悉其他语言中的选项类型，则移动选项的行为类似于那些具有几个值得注意的例外的选项，因为该选项可以包含 kind 资源的值。特别是，某些操作，如 get_with_default 和 destroy_with_default 要求元素类型 T 是可复制类型。</p>
<p>选件模块的 API 如下</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Generic type abstraction of a value that may, or may not, be present. Can contain
a value of either <code>resource</code> or <code>copyable</code> kind.</p>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<p>可能存在或不存在的值的通用类型抽象。可以包含资源或可复制类型的值。</p>
<pre><code class="language-move">    struct Option&lt;T&gt;;
</code></pre>
<h3 id="functions-2"><a class="header" href="#functions-2">Functions</a></h3>
<p>Create an empty <code>Option</code> of that can contain a value of <code>Element</code> type.</p>
<h3 id="功能"><a class="header" href="#功能">功能</a></h3>
<p>创建一个可以包含元素类型值的空选项。</p>
<pre><code class="language-move">    public fun none&lt;Element&gt;(): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Create a non-empty <code>Option</code> type containing a value <code>e</code> of type <code>Element</code>.</p>
<p>创建一个包含 Element 类型的值 e 的非空 Option 类型。</p>
<pre><code class="language-move">    public fun some&lt;Element&gt;(e: T): Option&lt;Element&gt;;
</code></pre>
<hr />
<p>Return an immutable reference to the value inside the option <code>opt_elem</code>
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>返回对选项 opt_elem 中值的不可变引用 如果 opt_elem 不包含值，将中止。</p>
<pre><code class="language-move">    public fun borrow&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): &amp;Element;
</code></pre>
<hr />
<p>Return a reference to the value inside <code>opt_elem</code> if it contains one. If
<code>opt_elem</code> does not contain a value the passed in <code>default_ref</code> reference will be returned.
Does not abort.</p>
<p>如果它包含一个，则返回对 opt_elem 内的值的引用。如果 opt_elem 不包含值，则将返回传入的 default_ref 引用。不中止。</p>
<pre><code class="language-move">    public fun borrow_with_default&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, default_ref: &amp;Element): &amp;Element;
</code></pre>
<hr />
<p>Return a mutable reference to the value inside <code>opt_elem</code>. Will abort if
<code>opt_elem</code> does not contain a value.</p>
<p>返回对 opt_elem 中值的可变引用。如果 opt_elem 不包含值，将中止。</p>
<pre><code class="language-move">    public fun borrow_mut&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): &amp;mut Element;
</code></pre>
<hr />
<p>Convert an option value that contains a value to one that is empty in-place by
removing and returning the value stored inside <code>opt_elem</code>.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>通过删除并返回存储在 opt_elem 中的值，将包含值的选项值转换为就地为空的值。如果 opt_elem 不包含值，将中止。</p>
<pre><code class="language-move">    public fun extract&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Return the value contained inside the option <code>opt_elem</code> if it contains one.
Will return the passed in <code>default</code> value if <code>opt_elem</code> does not contain a
value. The <code>Element</code> type that the <code>Option</code> type is instantiated with must be
of <code>copyable</code> kind in order for this function to be callable.</p>
<p>如果它包含一个，则返回选项 opt_elem 中包含的值。如果 opt_elem 不包含值，将返回传入的默认值。用于实例化 Option 类型的 Element 类型必须是可复制类型，才能使此函数可调用。</p>
<pre><code class="language-move">    public fun get_with_default&lt;Element: copyable&gt;(opt_elem: &amp;Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Convert an empty option <code>opt_elem</code> to an option value that contains the value <code>e</code>.
Will abort if <code>opt_elem</code> already contains a value.</p>
<p>将空选项 opt_elem 转换为包含值 e 的选项值。如果 opt_elem 已经包含一个值，将中止。</p>
<pre><code class="language-move">    public fun fill&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element);
</code></pre>
<hr />
<p>Swap the value currently contained in <code>opt_elem</code> with <code>new_elem</code> and return the
previously contained value. Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>将 opt_elem 中当前包含的值交换为 new_elem 并返回先前包含的值。如果 opt_elem 不包含值，将中止。</p>
<pre><code class="language-move">    public fun swap&lt;Element&gt;(opt_elem: &amp;mut Option&lt;Element&gt;, e: Element): Element;
</code></pre>
<hr />
<p>Return true if <code>opt_elem</code> contains a value equal to the value of <code>e_ref</code>.
Otherwise, <code>false</code> will be returned.</p>
<p>如果 opt_elem 包含的值等于 e_ref 的值，则返回 true。否则，将返回 false。</p>
<pre><code class="language-move">    public fun contains&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;, e_ref: &amp;Element): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> does not contain a value.</p>
<p>如果 opt_elem 不包含值，则返回 true。</p>
<pre><code class="language-move">    public fun is_none&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Return <code>true</code> if <code>opt_elem</code> contains a value.</p>
<p>如果 opt_elem 包含一个值，则返回 true。</p>
<pre><code class="language-move">    public fun is_some&lt;Element&gt;(opt_elem: &amp;Option&lt;Element&gt;): bool;
</code></pre>
<hr />
<p>Unpack <code>opt_elem</code> and return the value that it contained.
Will abort if <code>opt_elem</code> does not contain a value.</p>
<p>解包 opt_elem 并返回它包含的值。如果 opt_elem 不包含值，将中止。</p>
<pre><code class="language-move">    public fun destroy_some&lt;Element&gt;(opt_elem: Option&lt;Element&gt;): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in. If <code>opt_elem</code> contained a value it
will be returned otherwise, the passed in <code>default</code> value will be returned.</p>
<p>销毁传入的 opt_elem 值。如果 opt_elem 包含值，则返回，否则返回传入的默认值。</p>
<pre><code class="language-move">    public fun destroy_with_default&lt;Element: copyable&gt;(opt_elem: Option&lt;Element&gt;, default: Element): Element;
</code></pre>
<hr />
<p>Destroys the <code>opt_elem</code> value passed in, <code>opt_elem</code> must be empty and not
contain a value. Will abort if <code>opt_elem</code> contains a value.</p>
<p>销毁传入的 opt_elem 值，opt_elem 必须为空且不包含值。如果 opt_elem 包含一个值，将中止。</p>
<pre><code class="language-move">    public fun destroy_none&lt;Element&gt;(opt_elem: Option&lt;Element&gt;);
</code></pre>
<h2 id="errors"><a class="header" href="#errors">errors</a></h2>
<p>Recall that each abort code in Move is represented as an unsigned 64-bit integer. The <code>errors</code> module defines a common interface that can be used to &quot;tag&quot; each of these abort codes so that they can represent both the error <strong>category</strong> along with an error <strong>reason</strong>.</p>
<p>Error categories are declared as constants in the <code>errors</code> module and are globally unique with respect to this module. Error reasons on the other hand are module-specific error codes, and can provide greater detail (perhaps, even a particular <em>reason</em>) about the specific error condition. This representation of a category and reason for each error code is done by dividing the abort code into two sections.</p>
<p>The lower 8 bits of the abort code hold the <em>error category</em>. The remaining 56 bits of the abort code hold the <em>error reason</em>.
The reason should be a unique number relative to the module which raised the error and can be used to obtain more information about the error at hand. It should mostly be used for diagnostic purposes as error reasons may change over time if the module is updated.</p>
<h2 id="错误"><a class="header" href="#错误">错误</a></h2>
<p>回想一下，Move 中的每个中止代码都表示为一个无符号的 64 位整数。 errors 模块定义了一个通用接口，可用于“标记”每个中止代码，以便它们可以表示错误类别和错误原因。</p>
<p>错误类别在错误模块中被声明为常量，并且相对于该模块是全局唯一的。另一方面，错误原因是特定于模块的错误代码，可以提供有关特定错误条件的更多详细信息（甚至可能是特定原因）。每个错误代码的类别和原因的这种表示是通过将中止代码分为两部分来完成的。</p>
<p>中止代码的低 8 位保存错误类别。中止代码的剩余 56 位保存错误原因。原因应该是相对于引发错误的模块的唯一编号，并且可用于获取有关手头错误的更多信息。它应该主要用于诊断目的，因为如果更新模块，错误原因可能会随着时间而改变。</p>
<table><thead><tr><th>Category</th><th>Reason</th></tr></thead><tbody>
<tr><td>8 bits</td><td>56 bits</td></tr>
</tbody></table>
<p>Since error categories are globally stable, these present the most stable API and should in general be what is used by clients to determine the messages they may present to users (whereas the reason is useful for diagnostic purposes). There are public functions in the <code>errors</code> module for creating an abort code of each error category with a specific <code>reason</code> number (represented as a <code>u64</code>).</p>
<p>由于错误类别是全局稳定的，因此它们提供了最稳定的 API，通常应该是客户端用来确定它们可能呈现给用户的消息的内容（而原因对于诊断目的很有用）。错误模块中有公共函数，用于为每个错误类别创建一个带有特定原因号的中止代码（表示为 u64）。</p>
<h3 id="constants-1"><a class="header" href="#constants-1">Constants</a></h3>
<p>The system is in a state where the performed operation is not allowed.</p>
<h3 id="常数-1"><a class="header" href="#常数-1">常数</a></h3>
<p>系统处于不允许执行的操作的状态。</p>
<pre><code class="language-move">    const INVALID_STATE: u8 = 1;
</code></pre>
<hr />
<p>A specific account address was required to perform an operation, but a different address from what was expected was encounterd.</p>
<p>执行操作需要特定的帐户地址，但遇到了与预期不同的地址。</p>
<pre><code class="language-move">    const REQUIRES_ADDRESS: u8 = 2;
</code></pre>
<hr />
<p>An account did not have the expected  role for this operation. Useful for Role Based Access Control (RBAC) error conditions.</p>
<p>帐户没有此操作的预期角色。对于基于角色的访问控制 (RBAC) 错误情况很有用。</p>
<pre><code class="language-move">    const REQUIRES_ROLE: u8 = 3;
</code></pre>
<hr />
<p>An account did not not have a required capability. Useful for RBAC error conditions.</p>
<p>帐户没有所需的功能。对于 RBAC 错误情况很有用。</p>
<pre><code class="language-move">    const REQUIRES_CAPABILITY: u8 = 4;
</code></pre>
<hr />
<p>A resource was expected, but did not exist under an address.</p>
<p>应有资源，但地址下不存在。</p>
<pre><code class="language-move">    const NOT_PUBLISHED: u8 = 5;
</code></pre>
<hr />
<p>Attempted to publish a resource under an address where one was already published.</p>
<p>尝试在已发布资源的地址下发布资源。</p>
<pre><code class="language-move">    const ALREADY_PUBLISHED: u8 = 6;
</code></pre>
<hr />
<p>An argument provided for an operation was invalid.</p>
<p>为操作提供的参数无效。</p>
<pre><code class="language-move">    const INVALID_ARGUMENT: u8 = 7;
</code></pre>
<hr />
<p>A limit on a value was exceeded.</p>
<p>超出了某个值的限制。</p>
<pre><code class="language-move">    const LIMIT_EXCEEDED: u8 = 8;
</code></pre>
<hr />
<p>An internal error (bug) has occurred.</p>
<p>发生内部错误（错误）。</p>
<pre><code class="language-move">    const INTERNAL: u8 = 10;
</code></pre>
<hr />
<p>A custom error category for extension points.</p>
<p>扩展点的自定义错误类别。</p>
<pre><code class="language-move">    const CUSTOM: u8 = 255;
</code></pre>
<hr />
<h3 id="functions-3"><a class="header" href="#functions-3">Functions</a></h3>
<p>Should be used in the case where invalid (global) state is encountered. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_STATE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<h3 id="函数-2"><a class="header" href="#函数-2">函数</a></h3>
<p>应该在遇到无效（全局）状态的情况下使用。构造具有指定原因和类别 INVALID_STATE 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun invalid_state(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account's address does not match a specific address. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ADDRESS</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果帐户的地址与特定地址不匹配，则应使用。构造具有指定原因和类别 REQUIRES_ADDRESS 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun requires_address(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a role did not match a required role when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_ROLE</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果在使用 RBAC 时角色与所需角色不匹配，则应使用该角色。构造具有指定原因和类别 REQUIRES_ROLE 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun requires_role(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an account did not have a required capability when using RBAC. Constructs an abort code with specified <code>reason</code> and category <code>REQUIRES_CAPABILITY</code>. Should be Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果帐户在使用 RBAC 时没有所需的功能，则应使用。构造具有指定原因和类别 REQUIRES_CAPABILITY 的中止代码。如果原因不适合 56 位，则应该是将中止。</p>
<pre><code class="language-move">    public fun requires_capability(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource did not exist where one was expected. Constructs an abort code with specified <code>reason</code> and category <code>NOT_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果资源在预期的地方不存在，则应使用该资源。构造具有指定原因和类别 NOT_PUBLISHED 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun not_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a resource already existed where one was about to be published. Constructs an abort code with specified <code>reason</code> and category <code>ALREADY_PUBLISHED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果资源已经存在且即将发布，则应使用该资源。构造一个具有指定原因和类别 ALREADY_PUBLISHED 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun already_published(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an invalid argument was passed to a function/operation. Constructs an abort code with specified <code>reason</code> and category <code>INVALID_ARGUMENT</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果将无效参数传递给函数/操作，则应使用。构造具有指定原因和类别 INVALID_ARGUMENT 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun invalid_argument(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if a limit on a specific value is reached, e.g., subtracting 1 from a value of 0. Constructs an abort code with specified <code>reason</code> and category <code>LIMIT_EXCEEDED</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果达到特定值的限制，则应使用，例如，从 0 中减去 1。构造具有指定原因和类别 LIMIT_EXCEEDED 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun limit_exceeded(reason: u64): u64;
</code></pre>
<hr />
<p>Should be used if an internal error or bug was encountered. Constructs an abort code with specified <code>reason</code> and category <code>INTERNAL</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>如果遇到内部错误或错误，应使用。构造具有指定原因和类别 INTERNAL 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun internal(reason: u64): u64;
</code></pre>
<hr />
<p>Used for extension points, should be not used under most circumstances. Constructs an abort code with specified <code>reason</code> and category <code>CUSTOM</code>. Will abort if <code>reason</code> does not fit in 56 bits.</p>
<p>用于扩展点，在大多数情况下不应该使用。构造具有指定原因和类别 CUSTOM 的中止代码。如果原因不适合 56 位，将中止。</p>
<pre><code class="language-move">    public fun custom(reason: u64): u64;
</code></pre>
<hr />
<h2 id="fixed_point32"><a class="header" href="#fixed_point32">fixed_point32</a></h2>
<p>The <code>fixed_point32</code> module defines a fixed-point numeric type with 32 integer bits and 32 fractional bits. Internally, this is represented as a <code>u64</code> integer wrapped in a struct to make a unique <code>fixed_point32</code> type. Since the numeric representation is a binary one, some decimal values may not be exactly representable, but it provides more than 9 decimal digits of precision both before and after the decimal point (18 digits total). For comparison, double precision floating-point has less than 16 decimal digits of precision, so you should be careful about using floating-point to convert these values to decimal.</p>
<h2 id="固定点32"><a class="header" href="#固定点32">固定点32</a></h2>
<p>fixed_point32 模块定义了一个具有 32 个整数位和 32 个小数位的定点数值类型。在内部，这表示为一个包裹在结构中的 u64 整数，以形成唯一的 fixed_point32 类型。由于数字表示是二进制的，因此某些十进制值可能无法精确表示，但它在小数点前后都提供了超过 9 位的精度（总共 18 位）。作为比较，双精度浮点的精度小于 16 位小数，因此在使用浮点将这些值转换为十进制时应小心。</p>
<h3 id="types-1"><a class="header" href="#types-1">Types</a></h3>
<p>Represents a fixed-point numeric number with 32 fractional bits.</p>
<h3 id="类型-1"><a class="header" href="#类型-1">类型</a></h3>
<p>表示具有 32 个小数位的定点数值。</p>
<pre><code class="language-move">    struct FixedPoint32;
</code></pre>
<h3 id="functions-4"><a class="header" href="#functions-4">Functions</a></h3>
<p>Multiply a u64 integer by a fixed-point number, truncating any fractional part of the product. This will abort if the product overflows.</p>
<h3 id="函数-3"><a class="header" href="#函数-3">函数</a></h3>
<p>将 u64 整数乘以定点数，截断乘积的任何小数部分。如果产品溢出，这将中止。</p>
<pre><code class="language-move">    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64;
</code></pre>
<hr />
<p>Divide a u64 integer by a fixed-point number, truncating any fractional part of the quotient. This will abort if the divisor is zero or if the quotient overflows.</p>
<p>将 u64 整数除以定点数，截断商的任何小数部分。如果除数为零或商溢出，这将中止。</p>
<pre><code class="language-move">    public fun divide_u64(val: u64, divisor: FixedPoint32): u64;
</code></pre>
<hr />
<p>Create a fixed-point value from a rational number specified by its numerator and denominator. Calling this function should be preferred for using <code>fixed_point32::create_from_raw_value</code> which is also available. This will abort if the denominator is zero. It will also abort if the numerator is nonzero and the ratio is not in the range $2^{-32}\ldots2^{32}-1$. When specifying decimal fractions, be careful about rounding errors: if you round to display $N$ digits after the decimal point, you can use a denominator of $10^N$ to avoid numbers where the very small imprecision in the binary representation could change the rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.</p>
<p>根据分子和分母指定的有理数创建定点值。使用也可用的 fixed_point32::create_from_raw_value 应该首选调用此函数。如果分母为零，这将中止。如果分子不为零并且比率不在 $2
{-32}ldots2
{32}-1$ 范围内，它也会中止。指定小数时，请注意舍入错误：如果四舍五入以显示小数点后的 $N$ 个数字，则可以使用分母 $10
N$ 来避免二进制表示中非常小的不精确性可能会改变四舍五入，例如，0.0125 将向下舍入为 0.012，而不是向上舍入为 0.013。</p>
<pre><code class="language-move">    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32;
</code></pre>
<hr />
<p>Create a fixedpoint value from a raw <code>u64</code> value.</p>
<p>从原始 u64 值创建定点值。</p>
<pre><code class="language-move">    public fun create_from_raw_value(value: u64): FixedPoint32;
</code></pre>
<hr />
<p>Returns <code>true</code> if the decimal value of <code>num</code> is equal to zero.</p>
<p>如果 num 的十进制值等于 0，则返回 true。</p>
<pre><code class="language-move">    public fun is_zero(num: FixedPoint32): bool;
</code></pre>
<hr />
<p>Accessor for the raw <code>u64</code> value. Other less common operations, such as adding or subtracting <code>FixedPoint32</code> values, can be done using the raw values directly.</p>
<p>原始 u64 值的访问器。其他不太常见的操作，例如添加或减去 FixedPoint32 值，可以直接使用原始值完成。</p>
<pre><code class="language-move">    public fun get_raw_value(num: FixedPoint32): u64;
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-编码约定"><a class="header" href="#move-编码约定">Move 编码约定</a></h1>
<p>本节列出了 Move 团队认为有用的一些基本的 Move 编码约定。这些只是建议，如果你喜欢其他格式指南和约定，你可以随时使用它们。</p>
<h2 id="命名-2"><a class="header" href="#命名-2">命名</a></h2>
<ul>
<li><strong>模块名称</strong>：应该使用小写的蛇形命名法，例如：<code>fixed_point32</code>、<code>vector</code>。</li>
<li><strong>类型名称</strong>：如果不是原生数据类型，则应使用驼峰命名法，例如：<code>Coin</code>、<code>RoleId</code>。</li>
<li><strong>函数名称</strong>：应该使用小写的蛇形命名法，例如：<code>destroy_empty</code>。</li>
<li><strong>常量名称</strong>：应该使用大写的蛇形命名法，例如：<code>REQUIRES_CAPABILITY</code>。</li>
<li>泛型类型应该具备描述性，当然在适当的情况下也可以是反描述性的，例如：Vector 泛型类型的参数可以是 <code>T</code> 或 <code>Element</code>。大多数情况下，模块中的“主”类型命名应该与模块名相同，例如：<code>option::Option</code>，<code>fixed_point32::FixedPoint32</code>。</li>
<li><strong>模块文件名称</strong>：应该与模块名相同，例如：<code>Option.move</code>。</li>
<li><strong>脚本文件名称</strong>：应该使用小写的蛇形命名法，并且应该与脚本中的“主”函数名匹配。</li>
<li><strong>混合文件名称</strong>：如果文件包含多个模块和/或脚本，文件命名应该使用小写的蛇形命名法，并且不需要与内部的任何特定模块/脚本名匹配。</li>
</ul>
<h2 id="导入"><a class="header" href="#导入">导入</a></h2>
<ul>
<li>所有模块的 <code>use</code> 语句都应该位于模块的顶部。</li>
<li>函数应该从声明它们的模块中完全限定地导入和使用, 而不是在顶部导入。</li>
<li>类型应该在顶部导入。如果存在名称冲突，应使用 <code>as</code> 在本地适当地重命名类型。</li>
</ul>
<p>例如，如果有一个模块：</p>
<pre><code class="language-move">module 0x1::foo {
    struct Foo { }
    const CONST_FOO: u64 = 0;
    public fun do_foo(): Foo { Foo{} }
    ...
}
</code></pre>
<p>此时将被导入并使用：</p>
<pre><code class="language-move">module 0x1::bar {
    use 0x1::foo::{Self, Foo};

    public fun do_bar(x: u64): Foo {
        if (x == 10) {
            foo::do_foo()
        } else {
            abort 0
        }
    }
    ...
}
</code></pre>
<p>并且，如果在导入两个模块时存在本地名称冲突：</p>
<pre><code class="language-move">module other_foo {
    struct Foo {}
    ...
}

module 0x1::importer {
    use 0x1::other_foo::Foo as OtherFoo;
    use 0x1::foo::Foo;
    ...
}
</code></pre>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<ul>
<li>每个模块、结构体和公共函数声明都应该有对应的注释。</li>
<li>Move 有文档注释 <code>///</code>，常规单行注释 <code>//</code>，块注释 <code>/* */</code>，和块文档注释 <code>/** */</code>。</li>
</ul>
<h2 id="格式化"><a class="header" href="#格式化">格式化</a></h2>
<p>Move 团队计划编写一个自动格式化程序来执行格式化约定。然而，在此期间：</p>
<ul>
<li>除 <code>script</code> 和 <code>address</code> 块外，其他的内容应使用四个空格的缩进。</li>
<li>每行代码，如果超过 100 个字符，应该换行。</li>
<li>结构体和常量应该在模块中的所有函数之前声明。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
