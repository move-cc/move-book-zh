<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函数（Functions） - Move Book 中文版</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html" class="active"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Book 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.</p>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>Move 中的函数语法在模块函数和脚本函数之间共享。模块内部的函数是可重用的，而脚本函数仅用于调用事务一次。</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.</p>
<h2 id="声明"><a class="header" href="#声明">声明</a></h2>
<p>函数用 fun 关键字声明，后跟函数名、类型参数、形参、返回类型、获取注解，最后是函数体。</p>
<pre><code class="language-text">fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;acquires [identifier],*&gt; &lt;function_body&gt;
</code></pre>
<p>For example</p>
<p>例如</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.</p>
<h3 id="可见性"><a class="header" href="#可见性">可见性</a></h3>
<p>默认情况下，模块函数只能在同一个模块内调用。这些内部（有时称为私有）函数不能从其他模块或脚本调用。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>To allow access from other modules or from scripts, the function must be declared <code>public</code> or <code>public(friend)</code>.
要允许从其他模块或脚本访问，该函数必须声明为 public 或 public(friend)。</p>
<h4 id="public-visibility"><a class="header" href="#public-visibility"><code>public</code> visibility</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module or script. As shown in the following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>the function defined in a script.</li>
</ul>
<h4 id="public-可见性"><a class="header" href="#public-可见性"><code>public</code> 可见性</a></h4>
<p>公共函数可以被任何模块或脚本中定义的任何函数调用。如以下示例所示，可以通过以下方式调用公共函数：</p>
<p>在同一模块中定义的其他功能，
在另一个模块中定义的函数，或
脚本中定义的函数。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
</code></pre>
<h4 id="publicfriend-visibility"><a class="header" href="#publicfriend-visibility"><code>public(friend)</code> visibility</a></h4>
<p>The <code>public(friend)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give more control about where a function can be used. A <code>public(friend)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>functions defined in modules which are explicitly specified in the <strong>friend list</strong> (see <a href="./friends.html">Friends</a> on how to specify the friend list).</li>
</ul>
<p>Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a <code>public(friend)</code> function.</p>
<h4 id="publicfriend-可见性"><a class="header" href="#publicfriend-可见性"><code>public(friend)</code> 可见性</a></h4>
<p>public(friend) 可见性修饰符是 public 修饰符的一种更受限制的形式，可以更好地控制函数的使用位置。可以通过以下方式调用公共（朋友）函数：</p>
<p>在同一模块中定义的其他功能，或
在好友列表中明确指定的模块中定义的函数（请参阅好友了解如何指定好友列表）。
请注意，由于我们不能将脚本声明为模块的朋友，因此脚本中定义的函数永远不能调用 public(friend) 函数。</p>
<pre><code class="language-move=">address 0x42 {
module m {
    friend 0x42::n;  // friend declaration
    public(friend) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
</code></pre>
<h3 id="entry-modifier"><a class="header" href="#entry-modifier"><code>entry</code> modifier</a></h3>
<p>The <code>entry</code> modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-<code>entry</code> function will be called from a Move program already in execution.</p>
<p>Essentially, <code>entry</code> functions are the &quot;main&quot; functions of a module, and they specify where Move programs start executing.</p>
<p>Note though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p>For example:</p>
<h3 id="entry-修饰符"><a class="header" href="#entry-修饰符"><code>entry</code> 修饰符</a></h3>
<p>entry 修饰符旨在允许像脚本一样安全直接地调用模块函数。这允许模块编写者指定哪些函数可以开始执行。然后，模块编写者知道任何非入口函数都将从已经在执行的 Move 程序中调用。</p>
<p>本质上，入口函数是模块的“主要”函数，它们指定 Move 程序开始执行的位置。</p>
<p>但请注意，其他 Move 函数仍然可以调用入口函数。因此，虽然它们可以作为 Move 程序的开始，但它们并不局限于这种情况。</p>
<p>例如：</p>
<pre><code class="language-move=">address 0x42 {
module m {
    public entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
</code></pre>
<p>Even internal functions can be marked as <code>entry</code>! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)
甚至内部函数也可以标记为入口！这使您可以保证仅在执行开始时调用该函数（假设您没有在模块的其他地方调用它）</p>
<pre><code class="language-move=">address 0x42 {
module m {
    entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}

module other {
    public entry fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<h3 id="name"><a class="header" href="#name">Name</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, function names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>函数名称可以以字母 a 到 z 或字母 A 到 Z 开头。在第一个字符之后，函数名称可以包含下划线 <code>_</code>、字母 a 到 z、字母 A 到 Z 或数字 0 到 9。</p>
<pre><code class="language-move">fun FOO() {}
fun bar_42() {}
fun _bAZ19() {}
</code></pre>
<h3 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h3>
<p>After the name, functions can have type parameters</p>
<h3 id="类型参数"><a class="header" href="#类型参数">类型参数</a></h3>
<p>在名称之后，函数可以有类型参数</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅移动泛型。</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>函数参数使用局部变量名声明，后跟类型注释</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<p>我们将其读为 x 具有 u64 类型</p>
<p>函数根本不需要任何参数。</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<p>这对于创建新数据结构或空数据结构的函数很常见</p>
<pre><code class="language-move=">address 0x42 {
module example {
  struct Counter { count: u64 }

  fun new_counter(): Counter {
      Counter { count: 0 }
  }

}
}
</code></pre>
<h3 id="acquires"><a class="header" href="#acquires">Acquires</a></h3>
<p>When a function accesses a resource using <code>move_from</code>, <code>borrow_global</code>, or <code>borrow_global_mut</code>, the function must indicate that it <code>acquires</code> that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.</p>
<h3 id="收购"><a class="header" href="#收购">收购</a></h3>
<p>当函数使用 move_from、borrow_global 或 borrow_global_mut 访问资源时，该函数必须表明它获取了该资源。然后 Move 的类型系统使用它来确保对全局存储的引用是安全的，特别是没有对全局存储的悬空引用。</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }
}
}
</code></pre>
<p><code>acquires</code> annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.</p>
<p>还必须为模块内的传递调用添加获取注释。从另一个模块对这些函数的调用不需要使用这些获取进行注释，因为一个模块无法访问在另一个模块中声明的资源——因此不需要注释来确保引用安全。</p>
<pre><code class="language-move=">address 0x42 {
module example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &amp;signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from(addr); // acquires needed
        value
    }

    public fun extract_and_add(sender: address, receiver: &amp;signer) acquires Balance {
        let value = extract_balance(sender); // acquires needed here
        add_balance(receiver, value)
    }
}
}

address 0x42 {
module other {
    fun extract_balance(addr: address): u64 {
        0x42::example::extract_balance(addr) // no acquires needed
    }
}
}
</code></pre>
<p>A function can <code>acquire</code> as many resources as it needs to</p>
<p>一个函数可以根据需要获取尽可能多的资源</p>
<pre><code class="language-move=">address 0x42 {
module example {
    use std::vector;

    struct Balance has key { value: u64 }
    struct Box&lt;T&gt; has key { items: vector&lt;T&gt; }

    public fun store_two&lt;Item1: store, Item2: store&gt;(
        addr: address,
        item1: Item1,
        item2: Item2,
    ) acquires Balance, Box {
        let balance = borrow_global_mut&lt;Balance&gt;(addr); // acquires needed
        balance.value = balance.value - 2;
        let box1 = borrow_global_mut&lt;Box&lt;Item1&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box1.items, item1);
        let box2 = borrow_global_mut&lt;Box&lt;Item2&gt;&gt;(addr); // acquires needed
        vector::push_back(&amp;mut box2.items, item2);
    }
}
}
</code></pre>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<h3 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h3>
<p>在参数之后，函数指定其返回类型。</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using tuples, a function can return multiple values</p>
<p>这里：u64 表示函数的返回类型是u64。</p>
<p>使用元组，一个函数可以返回多个值</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These functions are equivalent</p>
<p>如果未指定返回类型，则该函数具有隐式返回类型 unit ()。这些功能是等价的</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p><code>script</code> functions must have a return type of unit <code>()</code></p>
<p>脚本函数的返回类型必须为 unit ()</p>
<pre><code class="language-move=">script {
    fun do_nothing() {
    }
}
</code></pre>
<p>As mentioned in the <a href="./tuples.html">tuples section</a>, these tuple &quot;values&quot; are virtual and do not exist at runtime. So for a function that returns unit <code>()</code>, it will not be returning any value at all during execution.</p>
<p>如元组部分所述，这些元组“值”是虚拟的，在运行时不存在。因此，对于返回 unit () 的函数，它在执行期间根本不会返回任何值。</p>
<h3 id="function-body"><a class="header" href="#function-body">Function body</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the sequence</p>
<h3 id="函数体"><a class="header" href="#函数体">函数体</a></h3>
<p>函数体是一个表达式块。函数的返回值是序列中的最后一个值</p>
<pre><code class="language-move=">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="#returning-values">the section below for more information on returns</a></p>
<p>For more information on expression blocks, see <a href="./variables.html">Move variables</a>.</p>
<p>有关退货的更多信息，请参阅以下部分</p>
<p>有关表达式块的更多信息，请参阅移动变量。</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that <code>native</code> functions are used for either standard library code or for functionality needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code such as <code>vector</code></p>
<h3 id="原生函数"><a class="header" href="#原生函数">原生函数</a></h3>
<p>有些函数没有指定主体，而是由 VM 提供的主体。这些函数被标记为原生。</p>
<p>如果不修改 VM 源代码，程序员就无法添加新的本地函数。此外，本机函数的意图是用于标准库代码或给定 Move 环境所需的功能。</p>
<p>您可能会看到的大多数本机函数都在标准库代码中，例如向量</p>
<pre><code class="language-move=">module std::vector {
    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
    ...
}
</code></pre>
<h2 id="calling"><a class="header" href="#calling">Calling</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<h2 id="调用"><a class="header" href="#调用">调用</a></h2>
<p>调用函数时，名称可以通过别名或完全限定指定</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun zero(): u64 { 0 }
}
}

script {
    use 0x42::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<p>调用函数时，必须为每个参数指定一个参数。</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<p>可以指定或推断类型参数。两个调用是等价的。</p>
<pre><code class="language-move=">address 0x42 {
module example {
    public fun id&lt;T&gt;(x: T): T { x }
}
}

script {
    use 0x42::example;
    fun call_all() {
        example::id(0);
        example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅移动泛型。</p>
<h2 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<p>一个函数的结果，它的“返回值”，是它的函数体的最终值。例如</p>
<pre><code class="language-move=">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p><a href="#function-body">As mentioned above</a>, the function's body is an <a href="./variables.html">expression block</a>. The expression block can sequence various statements, and the final expression in the block will be be the value of that block</p>
<p>如上所述，函数体是一个表达式块。表达式块可以对各种语句进行排序，块中的最终表达式将是该块的值</p>
<pre><code class="language-move=">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is <code>double_x + double_y</code></p>
<p>这里的返回值为 double_x + double_y</p>
<h3 id="return-expression"><a class="header" href="#return-expression"><code>return</code> expression</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit <code>return</code> expression:</p>
<h3 id="返回表达式"><a class="header" href="#返回表达式">返回表达式</a></h3>
<p>函数隐式返回其主体计算的值。但是，函数也可以使用显式返回表达式：</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<p>这两个功能是等价的。在这个稍微复杂的示例中，该函数减去两个 u64 值，但如果第二个值太大，则提前返回 0：</p>
<pre><code class="language-move=">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:</p>
<p>请注意，这个函数的主体也可以写成 if (y x) 0 else x - y。</p>
<p>然而 return 真正闪耀的是在其他控制流结构的深处退出。在此示例中，函数遍历向量以查找给定值的索引：</p>
<pre><code class="language-move=">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two functions are equivalent:</p>
<p>使用不带参数的 return 是 return () 的简写。即以下两个函数是等价的：</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="structs-and-resources.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="structs-and-resources.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
