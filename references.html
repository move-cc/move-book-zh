<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>引用（References） - Move Book 中文版</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言（Introduction）</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本（Modules and Scripts）</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程（Move Tutorial）</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数（Integers）</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型（Bool）</a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址（Address）</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量（Vector）</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名（Signer）</a></li><li class="chapter-item expanded "><a href="references.html" class="active"><strong aria-hidden="true">8.</strong> 引用（References）</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和单值（Tuples and Unit）</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域（Local Variables and Scopes）</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式（Equality）</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言（Abort and Assert）</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句（Conditionals）</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环（While and Loop）</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数（Functions）</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源（Structs and Resources）</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量（Constants）</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型（Generics）</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力（Type Abilities）</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名（Uses and Aliases）</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数（Friends）</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包（Packages）</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试（Unit Tests）</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构（Global Storage Structure）</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作（Global Storage Operators）</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库（Standard Library）</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码约定（Coding Conventions）</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Book 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<p>For more details on the rules of references, see <a href="./structs-and-resources.html">Structs and Resources</a></p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<p>Move 有两种类型的引用：不可变的 &amp; 和可变的 &amp;mut。不可变引用是只读的，不能修改基础值（或其任何字段）。可变引用允许通过写入该引用进行修改。 Move 的类型系统强制执行防止引用错误的所有权规则。</p>
<p>有关引用规则的更多详细信息，请参阅结构和资源</p>
<h2 id="reference-operators"><a class="header" href="#reference-operators">Reference Operators</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<h2 id="引用运算符"><a class="header" href="#引用运算符">引用运算符</a></h2>
<p>Move 提供了用于创建和扩展引用以及将可变引用转换为不可变引用的运算符。在这里和其他地方，我们使用符号 e: T 来表示“表达式 e 具有类型 T”。</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to
extend an existing reference:</p>
<p>&amp;e.f 和 &amp;mut e.f 运算符既可用于创建对结构的新引用，也可用于扩展现有引用：</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<p>只要两个结构都在同一个模块中，具有多个字段的引用表达式就可以工作：</p>
<pre><code class="language-move">struct A { b: B }
struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
  &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<p>最后，请注意，不允许引用引用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // will not compile
</code></pre>
<h2 id="reading-and-writing-through-references"><a class="header" href="#reading-and-writing-through-references">Reading and Writing Through References</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<h2 id="通过参考文献阅读和写作"><a class="header" href="#通过参考文献阅读和写作">通过参考文献阅读和写作</a></h2>
<p>可以读取可变和不可变引用以生成引用值的副本。</p>
<p>只能编写可变引用。写入 <code>*x = v</code> 会丢弃先前存储在 x 中的值并用 v 更新它。</p>
<p>这两个操作都使用类 C 的 <code>*</code> 语法。但是，请注意，读是一个表达式，而写是一个突变，必须发生在等号的左侧。</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
<p>In order for a reference to be read, the underlying type must have the
<a href="./abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:</p>
<p>为了读取引用，基础类型必须具有复制能力，因为读取引用会创建值的新副本。此规则防止复制资源值：</p>
<pre><code class="language-move=">fun copy_resource_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="./abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:
双重：为了写入引用，基础类型必须具有删除能力，因为写入引用将丢弃（或“删除”）旧值。此规则可防止破坏资源值：</p>
<pre><code class="language-move=">fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-inference"><a class="header" href="#freeze-inference"><code>freeze</code> inference</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<h2 id="冻结推理"><a class="header" href="#冻结推理">冻结推理</a></h2>
<p>可变引用可以在需要不可变引用的上下文中使用：</p>
<pre><code class="language-move">let x = 7;
let y: &amp;mut u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:
这是因为在底层，编译器会在需要的地方插入冻结指令。以下是冻结推理的更多示例：</p>
<pre><code class="language-move=">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<h3 id="子类型化"><a class="header" href="#子类型化">子类型化</a></h3>
<p>通过这种冻结推断，Move 类型检查器可以将 &amp;mut T 视为 &amp;T 的子类型。如上所示，这意味着对于任何使用 &amp;T 值的表达式，也可以使用 &amp;mut T 值。此术语用于错误消息中，以简明扼要地表明在提供 &amp;T 的情况下需要 &amp;mut T。例如</p>
<pre><code class="language-move=">address 0x42 {
module example {
    fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
        *store = *new_value
    }

    fun subtype_examples() {
        let x: &amp;u64 = &amp;0;
        let y: &amp;mut u64 = &amp;mut 1;

        x = &amp;mut 1; // valid
        y = &amp;2; // invalid!

        read_and_assign(y, x); // valid
        read_and_assign(x, y); // invalid!
    }
}
}
</code></pre>
<p>will yield the following error messages
将产生以下错误消息</p>
<pre><code class="language-text">error:

    ┌── example.move:12:9 ───
    │
 12 │         y = &amp;2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &amp;2; // invalid!
    │             -- The type: '&amp;{integer}'
    ·
  9 │         let y: &amp;mut u64 = &amp;mut 1;
    │                -------- Is not a subtype of: '&amp;mut u64'
    │

error:

    ┌── example.move:15:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let x: &amp;u64 = &amp;0;
    │                ---- The type: '&amp;u64'
    ·
  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
    │                                -------- Is not a subtype of: '&amp;mut u64'
    │
</code></pre>
<p>The only other types currently that has subtyping are <a href="./tuples.html">tuples</a></p>
<p>当前唯一具有子类型的其他类型是元组</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p>即使存在相同引用的现有副本或扩展，可变引用和不可变引用也始终可以被复制和扩展：</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="./variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<p>对于熟悉 Rust 所有权系统的程序员来说，这可能会令人惊讶，因为他们会拒绝上面的代码。 Move 的类型系统在处理副本方面更加宽松，但在写入前确保可变引用的唯一所有权方面同样严格。</p>
<h3 id="references-cannot-be-stored"><a class="header" href="#references-cannot-be-stored">References Cannot Be Stored</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the <code>store</code> <a href="./abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>Currently, Move cannot support this because references cannot be
<a href="https://en.wikipedia.org/wiki/Serialization">serialized</a>, but <em>every Move value must be
serializable</em>. This requirement comes from Move's
<a href="./global-storage-structure.html">persistent global storage</a>, which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs <em>and</em> ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the <code>store</code> <a href="./abilities.html">ability</a>, but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.</p>
<h3 id="无法存储引用"><a class="header" href="#无法存储引用">无法存储引用</a></h3>
<p>引用和元组是唯一不能存储为结构的字段值的类型，这也意味着它们不能存在于全局存储中。当 Move 程序终止时，程序执行期间创建的所有引用都将被销毁；它们完全是短暂的。这个不变量对于没有存储能力的类型的值也是正确的，但请注意，引用和元组更进一步，因为从一开始就不允许在结构中。</p>
<p>这是 Move 和 Rust 之间的另一个区别，后者允许将引用存储在结构内。</p>
<p>目前，Move 无法支持这一点，因为引用无法序列化，但每个 Move 值都必须是可序列化的。这个需求来自于 Move 的持久化全局存储，它需要序列化值以在程序执行中持久化它们。结构可以写入全局存储，因此它们必须是可序列化的。</p>
<p>可以想象一种更奇特、更有表现力的类型系统，它允许将引用存储在结构中，并禁止这些结构存在于全局存储中。我们也许可以允许不具备存储能力的结构内部的引用，但这并不能完全解决问题：Move 有一个相当复杂的系统来跟踪静态引用安全，并且类型系统的这方面也必须扩展支持在结构内存储引用。简而言之，Move 的类型系统（尤其是与引用安全相关的方面）必须扩展以支持存储的引用。但随着语言的发展，我们一直在关注这一点。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="signer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="tuples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="signer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="tuples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
